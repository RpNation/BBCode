/** @typedef {import('./utils').astNode} astNode */
/** @typedef {import('./utils').bbscriptFuncMap} bbscriptFuncMap */
import { bbscriptParamTypes, isStop } from "./utils";
import { ConsoleLogger } from "../logger";

/**
 * @typedef {Object} bbscriptOptions
 * @property {string} callerId
 * @property {string} callerClass
 * @property {any} data
 * @property {BBScriptProcessor} processor
 * @property {Element} target
 */

export class BBScriptProcessor {
  /** @type {bbscriptOptions} */
  options;
  /** @type {bbscriptFuncMap} */
  functions;
  /**
   * @param {bbscriptFuncMap} bbscriptFunc
   * @param {bbscriptOptions} [defaultOptions={} as bbscriptOptions]
   */
  constructor(bbscriptFunc, defaultOptions = {}) {
    defaultOptions = {
      ...defaultOptions,
      processor: this,
    };
    this.options = defaultOptions;
    this.functions = bbscriptFunc;
  }
  /**
   * Processes and executes all commands in node tree
   * @param {astNode[]} nodeTree input node tree, generated by `parse()`
   * @param {string} callerId
   * @param {string} callerClass
   * @param {bbscriptOptions} [options=this.options] options to use
   * @returns {Promise<void>}
   */
  async execAll(nodeTree, callerId, callerClass, options = this.options) {
    options = {
      ...this.options,
      ...options,
      callerId,
      callerClass,
    };
    for (const node of nodeTree) {
      const res = await this.exec(node, options);
      if (isStop(res)) {
        return;
      }
    }
  }
  /**
   * Processes and executes a single node
   * @param {astNode} node node to process and execute
   * @param {bbscriptOptions} options bbscript options
   * @returns {(void|string|boolean|number|Promise<void>|import('./utils').bbscriptStop)} returns value if applicable
   */
  exec(node, options) {
    const functions = options.processor.functions;
    const callable = functions[node.name].func;
    if (callable) {
      const args = node.params;
      try {
        return callable(options, ...args);
      } catch (error) {
        ConsoleLogger.warn("BBScript Error", error, node.name, options);
      }
    } else {
      ConsoleLogger.info("invalid command", node.name, options);
    }
  }
  /**
   * Process raw string into AST
   * @param {string} raw input script
   * @returns {astNode[]}
   */
  parse(raw) {
    const nodeTree = [];
    for (let line of raw.split("\n")) {
      line = line.trim();
      if (!line || line.startsWith("//")) {
        continue;
      }
      try {
        nodeTree.push(this.process(this.functions, line)[0]);
      } catch (e) {
        ConsoleLogger.warn(e);
      }
    }
    return nodeTree;
  }
  /**
   * Processes input line into AST node
   * @private
   * @param {bbscriptFuncMap} functions valid bbscript functions
   * @param {string} input input string to process
   * @param {number} [idx=0] optional index of string to start from
   * @returns {[astNode, number]} parsed AST Node and last index
   */
  process(functions, input, idx = 0) {
    const [part1, ...parts] = input.split(/\s+/);
    const name = part1.toLowerCase();
    const params = parts.join(" ");
    const node = {
      name,
      params: [],
    };
    if (!(name in functions)) {
      throw new Error(`Invalid bbscript function name '${name}'`);
    }
    const foundFunc = functions[name];
    // required params
    for (const { types: validParamType, default: defaultValue } of foundFunc.params) {
      let value;
      if (idx >= params.length) {
        if (defaultValue) {
          value = defaultValue;
        } else if (defaultValue == null) {
          // optional param with function defined default
          continue;
        } else {
          ConsoleLogger.warn(`Missing Parameter for ${name}`, validParamType);
          continue;
        }
      }
      let isString = false;
      if (params[idx] === '"') {
        // process quoted string
        [value, idx] = this.getEnclosedParameter(params, idx);
        isString = true;
      } else if (params[idx] === "'") {
        // process quoted string
        [value, idx] = this.getEnclosedParameter(params, idx, "'");
        isString = true;
      } else if (validParamType.includes(bbscriptParamTypes.Function) && params[idx] === "(") {
        // process nested function
        try {
          const [childFunc, overallIdx] = this.getEnclosedParameter(params, idx, ")");
          [value] = this.process(functions, childFunc);
          idx = overallIdx;
        } catch (e) {
          ConsoleLogger.warn(e);
        }
      } else if (validParamType.includes(bbscriptParamTypes.Identifier) && params[idx] === "$") {
        let braceVar = false;
        try {
          braceVar = params[idx + 1] === "{";
        } catch {
          ConsoleLogger.warn(`$ found but no opening {`);
        }
        if (braceVar) {
          [value, idx] = this.getEnclosedParameter(params, ++idx, "}");
        }
      } else if (params[idx]) {
        // no clue what token is
        value = params.substring(idx).split(/\s+/, 2)[0];
        idx += value.length;
      }
      if (
        validParamType.includes(bbscriptParamTypes.Int) &&
        typeof value === "string" &&
        !isNaN(parseFloat(value))
      ) {
        // if numeric, convert it
        value = parseFloat(value);
      } else if (validParamType.includes(bbscriptParamTypes.String) && isString) {
        value;
      } else if (validParamType.includes(bbscriptParamTypes.Identifier)) {
        value = `_${value}_`;
      }
      if (value !== undefined && value !== null) {
        node.params.push(value);
      }
      while (params[idx]?.match(/\s/)) {
        // skip index to next non-space char
        idx++;
      }
    }
    return [node, idx];
  }
  /**
   * Processed an input string for a single block of string
   * @private
   * @param {string} input input string
   * @param {number} idx index to start from
   * @param {string} [close='"'] closing char to stop at
   * @param {boolean} [trimWrap=true] if `true`, will remove opening and closing chars
   * @returns {[string, number]} found parameter and closing index
   */
  getEnclosedParameter(input, idx, close = '"', trimWrap = true) {
    const startIdx = idx;
    const remainder = input.slice(startIdx);
    const length = input.length;
    idx++;
    while (idx < length) {
      const closeIndex = input.indexOf(close, idx);
      if (!closeIndex) {
        idx = length;
        break;
      }
      // escaped close "
      if (input[closeIndex - 1] === "\\") {
        idx = closeIndex + 1;
        continue;
      }
      idx = closeIndex;
      break;
    }
    if (idx >= length && input[idx] !== close) {
      throw new Error('missing closing "');
    }
    const value = remainder.substring(trimWrap ? 1 : 0, idx - startIdx + (trimWrap ? 0 : 1));
    idx++;
    return [value, idx];
  }
}
