{"version":3,"file":"bbcode-parser.min.js","sources":["../../node_modules/@bbob/preset/es/index.js","../../bbcode-src/utils/common.js","../../bbcode-src/tags/alignment.js","../../bbcode-src/tags/anchor.js","../../bbcode-src/tags/font.js","../../bbcode-src/tags/heightrestrict.js","../../bbcode-src/tags/mail.js","../../bbcode-src/tags/size.js","../../bbcode-src/tags/textmessage.js","../../node_modules/@bbob/plugin-helper/es/char.js","../../node_modules/@bbob/plugin-helper/es/helpers.js","../../node_modules/@bbob/plugin-helper/es/TagNode.js","../../bbcode-src/tags/tabs.js","../../bbcode-src/tags/accordion.js","../../bbcode-src/tags/script.js","../../bbcode-src/preset.js","../../bbcode-src/tags/animation.js","../../bbcode-src/tags/background.js","../../bbcode-src/tags/block.js","../../bbcode-src/tags/blockquote.js","../../bbcode-src/tags/border.js","../../bbcode-src/tags/lineBreak.js","../../bbcode-src/tags/centerblock.js","../../bbcode-src/tags/check.js","../../bbcode-src/tags/class.js","../../bbcode-src/tags/code.js","../../bbcode-src/tags/color.js","../../bbcode-src/tags/comment.js","../../bbcode-src/tags/div.js","../../bbcode-src/tags/divide.js","../../bbcode-src/tags/fieldset.js","../../bbcode-src/tags/header.js","../../bbcode-src/tags/highlight.js","../../bbcode-src/tags/imagefloat.js","../../bbcode-src/tags/spoiler.js","../../bbcode-src/tags/justify.js","../../bbcode-src/tags/newspaper.js","../../bbcode-src/tags/note.js","../../bbcode-src/tags/ooc.js","../../bbcode-src/tags/pindent.js","../../bbcode-src/tags/plain.js","../../bbcode-src/tags/print.js","../../bbcode-src/tags/progress.js","../../bbcode-src/tags/thinprogress.js","../../bbcode-src/tags/scroll.js","../../bbcode-src/tags/side.js","../../bbcode-src/tags/subscript.js","../../bbcode-src/tags/superscript.js","../../bbcode-src/tags/discourse-core-replacement.js","../../node_modules/@bbob/parser/es/Token.js","../../node_modules/@bbob/parser/es/utils.js","../../node_modules/@bbob/parser/es/lexer.js","../../node_modules/@bbob/parser/es/parse.js","../../node_modules/@bbob/core/es/utils.js","../../node_modules/@bbob/core/es/index.js","../../node_modules/@bbob/html/es/index.js","../../bbcode-src/plugins/preserveWhitespace.js","../../bbcode-src/utils/postprocess.js","../../bbcode-src/plugins/lineBreak.js","../../bbcode-src/utils/preprocess.js","../../bbcode-src/index.js"],"sourcesContent":["/* eslint-disable indent */ const isTagNode = (el)=>typeof el === 'object' && !!el.tag;\nfunction process(tags, tree, core, options) {\n    tree.walk((node)=>isTagNode(node) && tags[node.tag] ? tags[node.tag](node, core, options) : node);\n}\n/**\n * Creates preset for @bbob/core\n * @param defTags {Object}\n * @param processor {Function} a processor function of tree\n * @returns {function(*=): function(*=, *=): void}\n */ function createPreset(defTags, processor = process) {\n    const presetFactory = (opts = {})=>{\n        presetFactory.options = Object.assign(presetFactory.options || {}, opts);\n        const presetExecutor = (tree, core)=>processor(defTags, tree, core, presetFactory.options);\n        presetExecutor.options = presetFactory.options;\n        return presetExecutor;\n    };\n    presetFactory.extend = (callback)=>createPreset(callback(defTags, presetFactory.options), processor);\n    return presetFactory;\n}\nexport { createPreset };\nexport default createPreset;\n","const toNode = (tag, attrs, content) => ({\n  tag,\n  attrs,\n  content,\n});\n\n/**\n * Preprocess attributes of a node to either combine all values into a single default value\n * or return a keyed attribute list\n * @param {any} attrs object of bbcode node attrs\n * @param {string[]} predefinedKeys array of predefined keys to be captured\n * @returns processed attributes\n */\nconst preprocessAttr = (attrs) => {\n  const keys = Object.keys(attrs).join(\" \");\n  const vals = Object.values(attrs).join(\" \");\n  if (keys === vals) {\n    return {\n      _default: vals,\n    };\n  } else {\n    return attrs;\n  }\n};\n\n/**\n * Attempts to return tag into its original form with proper attributes\n * @returns string of tag start\n */\nconst toOriginalStartTag = (node) => {\n  if (!node.attrs) {\n    return `[${node.tag}]`;\n  }\n  const attrs = preprocessAttr(node.attrs);\n  if (attrs._default) {\n    return `[${node.tag}=${attrs._default}]`;\n  } else {\n    return node.toTagStart();\n  }\n};\n\n/**\n * Given a string, find the first position of a regex match\n * @param {string} string to test against\n * @param {RegExp} regex to test with\n * @param {number} startpos starting position. Defaults to 0\n * @returns index of the first match of the regex in the string\n */\nconst regexIndexOf = (string, regex, startpos) => {\n  const indexOf = string.substring(startpos || 0).search(regex);\n  return indexOf >= 0 ? indexOf + (startpos || 0) : indexOf;\n};\n\nconst MD_NEWLINE_INJECT = \"<!-- bbcode injected newlines -->\\n\\n\";\nconst MD_NEWLINE_PRE_INJECT = \"\\n\\n<!-- bbcode pre injected newlines -->\";\nconst MD_NEWLINE_INJECT_COMMENT = \"<!-- bbcode injected newlines -->\";\n\nconst URL_REGEX =\n  /(http|ftp|https|upload):\\/\\/([\\w_-]+(?:(?:\\.[\\w_-]+)+))([\\w.,@?^=%&:\\/~+#-]*[\\w@?^=%&\\/~+#-])/;\nconst MD_URL_REGEX =\n  /\\!?\\[.*\\]\\((http|ftp|https|upload):\\/\\/([\\w_-]+(?:(?:\\.[\\w_-]+)+))([\\w.,@?^=%&:\\/~+#-]*[\\w@?^=%&\\/~+#-])\\)/;\nconst URL_REGEX_SINGLE_LINE = new RegExp(`^${URL_REGEX.source}|${MD_URL_REGEX.source}$`);\nconst ESCAPABLES_REGEX =\n  /((\\n|^)(?<fence>```+|~~~+)(?<fenceInfo>.*\\n))|(?<bbcode>\\[(?<bbcodeTag>i?code|plain)(=.*)?\\])|(?<backtick>(?<tickStart>`{1,2})(.*)(?<tickEnd>\\k<tickStart>))/im;\nconst MD_TABLE_REGEX = /^(\\|[^\\n]+\\|\\r?\\n)((?:\\| ?:?[-]+:? ?)+\\|)(\\n(?:\\|[^\\n]+\\|\\r?\\n?)*)?$/m;\n\n/**\n * Generates a random GUID.\n *\n * Mini Racer doesn't have the crypto module, so we can't use the built-in `crypto.randomUUID` function.\n * @returns {string} a GUID\n */\nfunction generateGUID() {\n  let d = new Date().getTime();\n  if (window.performance && typeof window.performance.now === \"function\") {\n    d += performance.now(); //use high-precision timer if available\n  }\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    // eslint-disable-next-line no-bitwise\n    const r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    // eslint-disable-next-line no-bitwise\n    return (c === \"x\" ? r : (r & 0x3) | 0x8).toString(16);\n  });\n}\n\nexport {\n  toNode,\n  toOriginalStartTag,\n  generateGUID,\n  preprocessAttr,\n  regexIndexOf,\n  MD_NEWLINE_INJECT,\n  MD_NEWLINE_INJECT_COMMENT,\n  MD_NEWLINE_PRE_INJECT,\n  URL_REGEX,\n  MD_URL_REGEX,\n  MD_TABLE_REGEX,\n  URL_REGEX_SINGLE_LINE,\n  ESCAPABLES_REGEX,\n};\n","import { toNode } from \"../utils/common\";\n/**\n * @file Adds [left], [center], and [right] to bbcode\n * @example [center]content[/center]\n */\nexport const alignment = {\n  left: (node) => toNode(\"div\", { class: \"bb-left\" }, node.content),\n  center: (node) => toNode(\"div\", { class: \"bb-center\" }, node.content),\n  right: (node) => toNode(\"div\", { class: \"bb-right\" }, node.content),\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n/**\n * @file Adds [id] and [goto] to bbcode\n * @example [a=your_anchor_name]An anchor[/a] [goto=your_anchor_name]Jump to an anchor[/goto]\n */\nexport const anchor = {\n    // name is not valid in HTML5; however, it correctly displays back while id does not\n    a: (node) => {\n        const attrs = preprocessAttr(node.attrs)._default || \"\";\n        return toNode(\"a\", { id: `user-anchor-${attrs.trim()}`, name: `user-anchor-${attrs.trim()}` }, node.content);\n      },\n      goto: (node) => {\n        const attrs = preprocessAttr(node.attrs)._default || \"\";\n        toNode(\"a\", { href: `#user-anchor-${attrs.trim()}` }, node.content);\n      }\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\nconst WEB_FONTS = [\n  \"arial\",\n  \"book antiqua\",\n  \"courier new\",\n  \"georgia\",\n  \"tahoma\",\n  \"times new roman\",\n  \"trebuchet ms\",\n  \"verdana\",\n];\nconst VALID_FONT_STYLES = {\n  thin: \"100\",\n  extralight: \"200\",\n  light: \"300\",\n  regular: \"400\",\n  medium: \"500\",\n  semibold: \"600\",\n  bold: \"700\",\n  extrabold: \"800\",\n  black: \"900\",\n};\n// registered axis tags https://learn.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg#registered-axis-tags\nconst REGISTERED_AXIS = [\"ital\", \"opsz\", \"slnt\", \"wdth\", \"wght\"];\n\nconst AXES_REGEX = /(?<named_weight>[a-zA-Z]*)?\\s?(?<weight>[0-9]*)?\\s?(?<italic>italic)?/;\n\nconst axesParser = (attrs) => {\n  let axes = {\n    ital: 0,\n    wght: 400,\n  };\n\n  if (attrs?.style) {\n    // user just copy pasted the name of the style on the google font site, probably\n    const style = attrs.style.trim().toLowerCase();\n    const matches = AXES_REGEX.exec(style).groups || {};\n    if (matches?.italic) {\n      axes.ital = 1;\n    }\n\n    const weight = matches.weight;\n    if (weight && weight >= 0 && weight <= 900) {\n      axes.wght = weight;\n    } else if (Object.keys(VALID_FONT_STYLES).includes(matches.named_weight || \"\")) {\n      axes.wght = VALID_FONT_STYLES[matches.named_weight];\n    }\n\n    axes = {\n      ...axes,\n      ...Object.fromEntries(Object.entries(attrs).filter(([key]) => REGISTERED_AXIS.includes(key))),\n    };\n  }\n  return axes;\n};\n\n/**\n * Create google font api url\n * @param {string} family name of font\n * @param {object<string, string>} axes custom font axes\n */\nconst googleFontApiBuild = (family, axes) => {\n  family = family.replaceAll(\" \", \"+\");\n  // google fonts requires axes names to be in alphabetical order\n  axes = Object.keys(axes)\n    .sort()\n    .reduce((obj, key) => {\n      obj[key] = axes[key];\n      return obj;\n    }, {});\n  const axesList = Object.keys(axes).join(\",\") + \"@\" + Object.values(axes).join(\",\");\n  return \"https://fonts.googleapis.com/css2?family=\" + family + \":\" + axesList;\n};\n\nexport const font = (node, options) => {\n  const attrs = preprocessAttr(node.attrs);\n  const fontFamily = attrs?._default || attrs.family || attrs.name;\n  if (fontFamily.trim() === \"\") {\n    return node.content;\n  }\n  if (WEB_FONTS.includes(fontFamily.trim().toLowerCase())) {\n    return toNode(\"span\", { style: \"font-family: \" + fontFamily }, node.content);\n  }\n\n  const axes = axesParser(attrs);\n  const url = googleFontApiBuild(fontFamily, axes);\n  options.data.fonts.add(url);\n\n  const italic = axes.ital === 1 ? \"italic\" : \"normal\";\n\n  const custom = Object.entries(axes).filter(([key]) => key !== \"wght\" && key !== \"ital\");\n  let fontVar = \"\";\n  if (custom.length) {\n    fontVar =\n      \"font-variation-settings: \" + custom.map(([key, val]) => `'${key}' ${val}`).join(\", \") + \";\";\n  }\n\n  return toNode(\n    \"span\",\n    {\n      style: `font-family: ${fontFamily}; font-weight: ${axes.wght}; font-style: ${italic}; ${fontVar}`,\n      \"data-font\": url,\n    },\n    node.content,\n  );\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * Parse the user provided height and return a valid height value\n * @param {Number} heightValue obtains the input of the user entered height (default is 700)\n * @returns A validated number less than 0.\n */\nfunction parseHeight(heightValue) {\n  const maxHeight = 700;\n  const parsedHeight =\n    heightValue && heightValue.trim() !== \"\" ? heightValue.replace(/[^\\d.]/g, \"\") : 0;\n\n  if (parsedHeight && parsedHeight >= 0 && parsedHeight <= maxHeight) {\n    return parsedHeight;\n  } else {\n    // if the value = 0 then nothing will be returned\n    return parsedHeight === 0 ? 0 : maxHeight;\n  }\n}\n\n/**\n * @file Adds [heightrestrict] to bbcode\n * @example [heightrestrict=50]content[/heightrestrict]\n */\nexport const heightrestrict = (node) => {\n  const attrs = preprocessAttr(node.attrs)._default;\n  const heightInput = parseHeight(attrs).toString();\n  // Return image's default size if heightrestrict did not involve a valid value\n  return heightInput === \"0\"\n    ? toNode(\"div\", { class: \"bb-height-restrict\" }, node.content)\n    : toNode(\n        \"div\",\n        { class: \"bb-height-restrict\", style: `height: ${heightInput}px;` },\n        node.content,\n      );\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n/**\n * @file Adds [mail] to bbcode\n * @param {string} [type=\"send\"] Denotes type of mail either send or receive\n * @param {string} [person=\"Unknown\"] Denotes the person in the To/From field\n * @param {string} [subject=\"Empty\"] Denotes the subject line of the email\n * @example [mail type=\"send\" person=\"John Doe\" subject=\"Hello World\"]content[/mail]\n */\n\nconst parseEmailContent = (content) => {\n  return toNode(\"div\", { class: \"bb-email-content\" }, content);\n};\n\nconst parseEmailSubject = (subject) => {\n  return toNode(\"div\", { class: \"bb-email-subject\" }, subject);\n};\n\nconst parseEmailPerson = (person) => {\n  return toNode(\"div\", { class: \"bb-email-address\" }, person);\n};\n\nconst emailHeader = toNode(\"div\", { class: \"bb-email-header\" }, \"\");\nconst emailFooter = toNode(\n  \"div\",\n  { class: \"bb-email-footer\" },\n  toNode(\"div\", { class: \"bb-email-button\" }, \"\")\n);\n\nexport const mail = (node) => {\n  const attributes = preprocessAttr(node.attrs);\n  let mailAttr = {\n    mailOption: (attributes.type || \"send\").toLowerCase(),\n    person: attributes.person || \"Unknown\",\n    subject: attributes.subject || \"Empty\",\n  };\n\n  return toNode(\n    \"div\",\n    {\n      class: \"bb-email\",\n      \"data-bb-email\": mailAttr.mailOption,\n    },\n    [\n      emailHeader,\n      parseEmailPerson(mailAttr.person),\n      parseEmailSubject(mailAttr.subject),\n      parseEmailContent(node.content),\n      emailFooter,\n    ]\n  );\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * Parses an inputted size value and returns the formatted valid font size\n * @param {string} fontValue the input of the size\n */\nfunction parseFontSize(fontValue) {\n  let value;\n  let fontSize = { valid: true };\n  const parsedSize = /(\\d+\\.?\\d?)(px|rem)?/i.exec(fontValue);\n  const sizeRanges = {\n    px_max: 36,\n    px_min: 8,\n    rem_max: 3,\n    rem_min: 0.2,\n    unitless_max: 7,\n    unitless_min: 1,\n  };\n\n  if (parsedSize && (value = parsedSize[1])) {\n    fontSize.unit = (parsedSize[2] || \"\").toLowerCase();\n    switch (fontSize.unit) {\n      case \"px\":\n        if (value > sizeRanges.px_max) {\n          value = sizeRanges.px_max;\n        } else if (value < sizeRanges.px_min) {\n          value = sizeRanges.px_min;\n        }\n        break;\n      case \"rem\":\n        if (value > sizeRanges.rem_max) {\n          value = sizeRanges.rem_max;\n        } else if (value < sizeRanges.rem_min) {\n          value = sizeRanges.rem_min;\n        }\n        break;\n      default:\n        if ((fontSize.valid = fontValue.length === value.length)) {\n          if (value > sizeRanges.unitless_max) {\n            value = sizeRanges.unitless_max;\n          } else if (value < sizeRanges.unitless_min) {\n            value = sizeRanges.unitless_min;\n          }\n        }\n        break;\n    }\n\n    fontSize.value = value;\n  }\n  return fontSize;\n}\n\nexport const size = (node) => {\n  const input = preprocessAttr(node.attrs)._default;\n  const fontSize = parseFontSize(input);\n  if (!fontSize.valid) {\n    return node.content;\n  }\n  let outputAttr = {};\n  if (fontSize.unit) {\n    outputAttr = { style: `font-size: ${fontSize.value}${fontSize.unit}` };\n  } else {\n    outputAttr = { \"data-size\": fontSize.value };\n  }\n  return toNode(\"span\", outputAttr, node.content);\n};\n","import { preprocessAttr } from \"../utils/common\";\n\n/**\n * @file Adds textmessage to bbcode\n * @exmaple [textmessage=Recipient][message=them]Hi [/message][message=me] Hey![/message][/textmessage]\n */\n\nconst ACCEPTED_OPTIONS = [\"me\", \"them\", \"right\", \"left\"];\nexport const textmessage = {\n  textmessage: (node) => {\n    const attr = preprocessAttr(node.attrs)._default || \"Recipient\";\n    const recipient = attr && attr.trim() !== \"\" ? attr : \"Recipient\";\n    return {\n      tag: \"div\",\n      attrs: {\n        class: \"bb-textmessage\",\n      },\n      content: [\n        {\n          tag: \"div\",\n          attrs: {\n            class: \"bb-textmessage-name\",\n          },\n          content: recipient,\n        },\n        {\n          tag: \"div\",\n          attrs: {\n            class: \"bb-textmessage-overflow\",\n          },\n          content: [\n            {\n              tag: \"div\",\n              attrs: {\n                class: \"bb-textmessage-content\",\n              },\n              content: node.content,\n            },\n          ],\n        },\n      ],\n    };\n  },\n  message: (node) => {\n    let option = preprocessAttr(node.attrs)._default.toLowerCase();\n    if (!ACCEPTED_OPTIONS.includes(option) || option === \"right\") {\n      option = \"me\";\n    }\n    if (option === \"left\") {\n      option = \"them\";\n    }\n\n    const senderAttrs = option === \"me\" ? \"bb-message-me\" : \"bb-message-them\";\n    return {\n      tag: \"div\",\n      attrs: {\n        class: senderAttrs,\n      },\n      content: [\n        {\n          tag: \"div\",\n          attrs: {\n            class: \"bb-message-content\",\n          },\n          content: node.content,\n        },\n      ],\n    };\n  },\n};\n","const N = '\\n';\nconst TAB = '\\t';\nconst F = '\\f';\nconst R = '\\r';\nconst EQ = '=';\nconst QUOTEMARK = '\"';\nconst SPACE = ' ';\nconst OPEN_BRAKET = '[';\nconst CLOSE_BRAKET = ']';\nconst SLASH = '/';\nconst BACKSLASH = '\\\\';\nexport { N, F, R, EQ, TAB, SPACE, SLASH, BACKSLASH, QUOTEMARK, OPEN_BRAKET, CLOSE_BRAKET };\n","import { N } from './char';\nconst isTagNode = (el)=>typeof el === 'object' && !!el.tag;\nconst isStringNode = (el)=>typeof el === 'string';\nconst isEOL = (el)=>el === N;\nconst keysReduce = (obj, reduce, def)=>Object.keys(obj).reduce(reduce, def);\nconst getNodeLength = (node)=>{\n    if (isTagNode(node)) {\n        return node.content.reduce((count, contentNode)=>count + getNodeLength(contentNode), 0);\n    }\n    if (isStringNode(node)) {\n        return node.length;\n    }\n    return 0;\n};\n/**\n * Appends value to Tag Node\n * @param {TagNode} node\n * @param value\n */ const appendToNode = (node, value)=>{\n    node.content.push(value);\n};\n/**\n * Replaces \" to &qquot;\n * @param {String} value\n */ const escapeHTML = (value)=>value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#039;')// eslint-disable-next-line no-script-url\n    .replace(/(javascript|data|vbscript):/gi, '$1%3A');\n/**\n * Acept name and value and return valid html5 attribute string\n * @param {String} name\n * @param {String} value\n * @return {string}\n */ const attrValue = (name, value)=>{\n    const type = typeof value;\n    const types = {\n        boolean: ()=>value ? `${name}` : '',\n        number: ()=>`${name}=\"${value}\"`,\n        string: ()=>`${name}=\"${escapeHTML(value)}\"`,\n        object: ()=>`${name}=\"${escapeHTML(JSON.stringify(value))}\"`\n    };\n    return types[type] ? types[type]() : '';\n};\n/**\n * Transforms attrs to html params string\n * @param values\n */ const attrsToString = (values)=>{\n    // To avoid some malformed attributes\n    if (values == null) {\n        return '';\n    }\n    return keysReduce(values, (arr, key)=>[\n            ...arr,\n            attrValue(key, values[key])\n        ], [\n        ''\n    ]).join(' ');\n};\n/**\n * Gets value from\n * @example\n * getUniqAttr({ 'foo': true, 'bar': bar' }) => 'bar'\n * @param attrs\n * @returns {string}\n */ const getUniqAttr = (attrs)=>keysReduce(attrs, (res, key)=>attrs[key] === key ? attrs[key] : null, null);\nexport { attrsToString, attrValue, appendToNode, escapeHTML, getNodeLength, getUniqAttr, isTagNode, isStringNode, isEOL };\n","import { OPEN_BRAKET, CLOSE_BRAKET, SLASH } from './char';\nimport { getNodeLength, appendToNode, attrsToString, attrValue, getUniqAttr } from './helpers';\nconst getTagAttrs = (tag, params)=>{\n    const uniqAattr = getUniqAttr(params);\n    if (uniqAattr) {\n        const tagAttr = attrValue(tag, uniqAattr);\n        const attrs = {\n            ...params\n        };\n        delete attrs[uniqAattr];\n        const attrsStr = attrsToString(attrs);\n        return `${tagAttr}${attrsStr}`;\n    }\n    return `${tag}${attrsToString(params)}`;\n};\nclass TagNode {\n    attr(name, value) {\n        if (typeof value !== 'undefined') {\n            this.attrs[name] = value;\n        }\n        return this.attrs[name];\n    }\n    append(value) {\n        return appendToNode(this, value);\n    }\n    get length() {\n        return getNodeLength(this);\n    }\n    toTagStart({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {\n        const tagAttrs = getTagAttrs(this.tag, this.attrs);\n        return `${openTag}${tagAttrs}${closeTag}`;\n    }\n    toTagEnd({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {\n        return `${openTag}${SLASH}${this.tag}${closeTag}`;\n    }\n    toTagNode() {\n        return new TagNode(this.tag.toLowerCase(), this.attrs, this.content);\n    }\n    toString({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {\n        const isEmpty = this.content.length === 0;\n        const content = this.content.reduce((r, node)=>r + node.toString({\n                openTag,\n                closeTag\n            }), '');\n        const tagStart = this.toTagStart({\n            openTag,\n            closeTag\n        });\n        if (isEmpty) {\n            return tagStart;\n        }\n        return `${tagStart}${content}${this.toTagEnd({\n            openTag,\n            closeTag\n        })}`;\n    }\n    constructor(tag, attrs, content){\n        this.tag = tag;\n        this.attrs = attrs;\n        this.content = Array.isArray(content) ? content : [\n            content\n        ];\n    }\n}\nTagNode.create = (tag, attrs = {}, content = [])=>new TagNode(tag, attrs, content);\nTagNode.isOf = (node, type)=>node.tag === type;\nexport { TagNode };\nexport default TagNode;\n","import { generateGUID, preprocessAttr, toNode, toOriginalStartTag } from \"../utils/common\";\nimport { isTagNode } from \"@bbob/plugin-helper\";\n\n/**\n * @file Adds [tabs][tab] to bbcode\n * @example [tabs][tab=name 1]content[/tab][tab=name 2]content[/tab][/tabs]\n */\nexport const tabs = (node) => {\n  const tabsList = node.content.filter(\n    (contentNode) => isTagNode(contentNode) && contentNode.tag === \"tab\",\n  );\n  const groupId = generateGUID();\n  tabsList.forEach((tabNode) => {\n    tabNode.isValid = true;\n    tabNode.groupId = groupId;\n  });\n  if (!tabsList.length) {\n    // no [tab] tags found\n    return [toOriginalStartTag(node), ...node.content, node.toTagEnd()];\n  }\n  tabsList[0].open = true;\n\n  return toNode(\n    \"div\",\n    {\n      class: \"bb-tabs\",\n    },\n    tabsList,\n  );\n};\n\n/**\n * [tab=name]content[/tab]\n * [tab name=\"name\" style=\"style\"]content[/tab]\n */\nexport const tab = (node) => {\n  if (!node.isValid) {\n    // not inside a [tabs] tag\n    return [toOriginalStartTag(node), ...node.content, node.toTagEnd()];\n  }\n  const attrs = preprocessAttr(node.attrs);\n  const name = attrs._default || attrs.name || \"Tab\";\n  const tabId = `tab-${name.replace(/\\W/g, \"_\")}-${generateGUID()}`;\n  return [\n    toNode(\"input\", {\n      type: \"radio\",\n      id: tabId,\n      name: \"tab-group-\" + node.groupId,\n      class: \"bb-tab\",\n      checked: node.open,\n    }),\n    toNode(\n      \"label\",\n      {\n        class: \"bb-tab-label\",\n        for: tabId,\n        style: attrs.style,\n      },\n      name,\n    ),\n    toNode(\n      \"div\",\n      {\n        class: \"bb-tab-content\",\n      },\n      node.content,\n    ),\n  ];\n};\n","import {\n  generateGUID,\n  preprocessAttr,\n  regexIndexOf,\n  toNode,\n  toOriginalStartTag,\n} from \"../utils/common\";\nimport { TagNode, isStringNode, isTagNode } from \"@bbob/plugin-helper\";\n\nconst SLIDE_TITLE_OPEN = Symbol(\"slide-title-open\");\nconst SLIDE_TITLE_CLOSE = Symbol(\"slide-title-close\");\nconst SLIDE_CLOSE = Symbol(\"slide-close\");\nconst SLIDE_REGEX =\n  /(?<slideTitleOpen>\\{slide=)|(?<slideTitleClose>\\})|(?<slideClose>\\{\\/slide\\})/i;\n\n/**\n * Adds the accordion tag\n * [accordion]{slide=name}content{/slide}[/accordion]\n *\n * [accordion][slide=name]content[/slide][/accordion]\n */\nconst accordion = (node) => {\n  const groupId = generateGUID();\n\n  // add support for existing {slide} tags style, due to copious amounts of existing content\n  // also the only way to get true custom content inside a slide due to nesting limitations\n  const markedContent = generateSlideMarkersFromContent(node.content);\n  const generatedSlides = generateSlidesFromMarkers(markedContent);\n\n  const filteredContent = generatedSlides\n    .filter((n) => isTagNode(n) && n.tag === \"slide\")\n    .map((content) => {\n      content.isValid = true;\n      content.groupId = groupId;\n      return content;\n    });\n  if (!filteredContent.length) {\n    // no [slide] tags found\n    return [toOriginalStartTag(node), ...node.content, node.toTagEnd()];\n  }\n\n  const attrs = preprocessAttr(node.attrs);\n\n  if (attrs._default) {\n    /** @type {string[]} */\n    const customSettings = attrs._default.split(\"|\").map((s) => s.trim());\n    if (customSettings.includes(\"bright\")) {\n      attrs.bright = true;\n    }\n    if (customSettings.includes(\"bcenter\")) {\n      attrs.bcenter = true;\n    }\n    if (customSettings.includes(\"bleft\")) {\n      attrs.bleft = true;\n    }\n    if (customSettings.includes(\"fleft\")) {\n      attrs.fleft = true;\n    }\n    if (customSettings.includes(\"fright\")) {\n      attrs.fright = true;\n    }\n    if (\n      customSettings.some((s) => s.endsWith(\"px\")) ||\n      customSettings.some((s) => s.endsWith(\"%\"))\n    ) {\n      attrs.width = customSettings.find((s) => s.endsWith(\"px\") || s.endsWith(\"%\"));\n    }\n  }\n\n  let classes = Object.keys(attrs)\n    .filter((s) => [\"bright\", \"bcenter\", \"bleft\", \"fleft\", \"fright\"].includes(s))\n    .join(\" \");\n  let style = \"\";\n  if (attrs.width?.endsWith(\"px\") || attrs.width?.endsWith(\"%\")) {\n    style = `width: ${attrs.width};`;\n  }\n  return toNode(\n    \"div\",\n    { class: \"bb-accordion \" + classes, \"data-group-id\": groupId, style },\n    filteredContent,\n  );\n};\n\n/**\n * Locates and splits all {slide} tag components into their respective parts while preserving remaining content\n * @param {(TagNode|string)[]} contentArr node content of the accordion tag\n *\n * @example\n * ```\n * [\"{slide=test}\", \"lorem ipsum\", \"{/slide}\"]\n * ```\n * becomes\n * ```\n * [SLIDE_TITLE_OPEN, \"test\", SLIDE_TITLE_CLOSE, \"lorem ipsum\", SLIDE_CLOSE]\n * ```\n */\nfunction generateSlideMarkersFromContent(contentArr) {\n  contentArr = [...contentArr]; // shallow clone. object nodes are not modified anyway\n\n  const newArr = [];\n  while (contentArr.length > 0) {\n    const content = contentArr[0];\n    if (isTagNode(content)) {\n      newArr.push(contentArr.shift());\n      continue;\n    }\n    const foundIndex = regexIndexOf(content, SLIDE_REGEX);\n    if (foundIndex === -1) {\n      newArr.push(contentArr.shift());\n      continue;\n    }\n    const match = content.match(SLIDE_REGEX);\n    const preContent = content.slice(0, foundIndex);\n    const postContent = content.slice(foundIndex + match[0].length);\n    if (preContent.length) {\n      newArr.push(preContent);\n    }\n    if (match.groups.slideTitleOpen) {\n      newArr.push(SLIDE_TITLE_OPEN);\n    }\n    if (match.groups.slideTitleClose) {\n      newArr.push(SLIDE_TITLE_CLOSE);\n    }\n    if (match.groups.slideClose) {\n      newArr.push(SLIDE_CLOSE);\n    }\n    if (postContent.length) {\n      contentArr[0] = postContent;\n    } else {\n      contentArr.shift();\n    }\n  }\n\n  return newArr;\n}\n\n/**\n * Generates slide nodes from markers\n * @param {(string | typeof SLIDE_TITLE_OPEN | typeof SLIDE_TITLE_CLOSE | typeof SLIDE_CLOSE | TagNode)[]} markedContent\n */\nfunction generateSlidesFromMarkers(markedContent) {\n  const nodes = [];\n  let currentSlide = null;\n  /** @type {typeof SLIDE_TITLE_OPEN | typeof SLIDE_TITLE_CLOSE | null} */\n  let prevMarker = null;\n  for (const content of markedContent) {\n    if (content === SLIDE_TITLE_OPEN && prevMarker === null) {\n      currentSlide = TagNode.create(\"slide\");\n      currentSlide.content = [];\n      currentSlide.customTitle = [];\n      prevMarker = SLIDE_TITLE_OPEN;\n    } else if (content === SLIDE_TITLE_CLOSE && prevMarker === SLIDE_TITLE_OPEN) {\n      prevMarker = SLIDE_TITLE_CLOSE;\n      continue;\n    } else if (content === SLIDE_CLOSE && currentSlide && prevMarker === SLIDE_TITLE_CLOSE) {\n      nodes.push(currentSlide);\n      currentSlide = null;\n      prevMarker = null;\n    } else if (currentSlide) {\n      if (prevMarker === SLIDE_TITLE_OPEN) {\n        currentSlide.customTitle.push(markerToString(content));\n      } else {\n        currentSlide.content.push(markerToString(content));\n      }\n    } else {\n      // no slide open, just add content\n      nodes.push(markerToString(content));\n    }\n  }\n  return nodes;\n}\n\n/**\n * Processes content into a string. Catches stray markers and converts them back into a string\n * @param {string | typeof SLIDE_TITLE_OPEN | typeof SLIDE_TITLE_CLOSE | typeof SLIDE_CLOSE} marker\n * @returns expected string\n */\nfunction markerToString(marker) {\n  switch (marker) {\n    case SLIDE_TITLE_OPEN:\n      return \"{slide=\";\n    case SLIDE_TITLE_CLOSE:\n      return \"}\";\n    case SLIDE_CLOSE:\n      return \"{/slide}\";\n    default:\n      return marker;\n  }\n}\n\nconst slide = (node) => {\n  if (!node.isValid) {\n    // not inside an [accordion] tag\n    return [toOriginalStartTag(node), ...node.content, node.toTagEnd()];\n  }\n  const attrs = preprocessAttr(node.attrs);\n  let title = [attrs.title || attrs._default || \"Slide\"];\n  let isOpen = !!attrs.open || false;\n  let titleAlign = attrs.left ? \"left\" : attrs.right ? \"right\" : attrs.center ? \"center\" : \"left\";\n  if (node.customTitle?.length) {\n    // slide was created from markers\n    title = node.customTitle;\n    // pull out old options from title if they exist\n    const possibleOptions = title\n      .filter((t) => typeof t === \"string\")\n      .join(\"\")\n      .toLowerCase()\n      .split(\"|\")\n      .map((s) => s.trim());\n    if (possibleOptions.includes(\"open\")) {\n      isOpen = true;\n    }\n    if (possibleOptions.includes(\"right\")) {\n      titleAlign = \"right\";\n    }\n    if (possibleOptions.includes(\"center\")) {\n      titleAlign = \"center\";\n    }\n    if (possibleOptions.includes(\"left\")) {\n      titleAlign = \"left\";\n    }\n    title = title.map((t) => {\n      if (isStringNode(t)) {\n        t = t.replace(/\\|(open|right|center|left)/gi, \"\");\n      }\n      return t;\n    });\n  }\n  return [\n    {\n      tag: \"details\",\n      attrs: { class: \"bb-slide\", open: isOpen },\n      content: [\n        {\n          tag: \"summary\",\n          attrs: {\n            class: \"bb-slide-title\",\n            style: `text-align: ${titleAlign}; ${attrs.style || \"\"}`,\n          },\n          content: title,\n        },\n        {\n          tag: \"div\",\n          attrs: { class: \"bb-slide-content\" },\n          content: node.content,\n        },\n      ],\n    },\n  ];\n};\n\nexport const accordionTags = { accordion, slide };\n","import { preprocessAttr } from \"../utils/common\";\n\nconst EVENTS = [\n  \"init\",\n  \"click\",\n  \"change\",\n  \"input\",\n  \"dblclick\",\n  \"mouseenter\",\n  \"mouseleave\",\n  \"scroll\",\n];\n\n/**\n * Script tag\n *\n * [script]content[/script]\n *\n * [script class=\"id\" on=\"event\" version=\"2\"]content[/script]\n */\nexport const script = (node, options) => {\n  const attrs = preprocessAttr(node.attrs);\n\n  if (!options.data.previewing && !options.data.commonGUID) {\n    // create a common GUID for the post\n    // only applicable for div, style, and script tags\n    // this is to prevent the same class name from being used in different posts\n    options.data.commonGUID = \"post-\" + Math.random().toString(36).substring(2, 7);\n  }\n  const classSuffix = options.data.previewing ? \"preview\" : options.data.commonGUID;\n\n  const onEvent =\n    (EVENTS.includes(attrs.on?.toLowerCase() || \"init\") && attrs.on?.toLowerCase()) || \"init\";\n\n  const scriptSetup = {\n    id: classSuffix,\n    class: attrs.class || \"\",\n    on: onEvent,\n    version: attrs.version || \"\",\n    content: node.content.join(\"\"),\n  };\n  options.data.bbscripts.push(scriptSetup);\n\n  return [];\n};\n","import { createPreset } from \"@bbob/preset\";\nimport { alignment } from \"./tags/alignment\";\nimport { anchor } from \"./tags/anchor\";\nimport { bg } from \"./tags/background\";\nimport { block } from \"./tags/block\";\nimport { blockquote } from \"./tags/blockquote\";\nimport { border } from \"./tags/border\";\nimport { centerblock } from \"./tags/centerblock\";\nimport { check } from \"./tags/check\";\nimport { code, icode, savenl } from \"./tags/code\";\nimport { color } from \"./tags/color\";\nimport { comment } from \"./tags/comment\";\nimport { divide } from \"./tags/divide\";\nimport { fieldset } from \"./tags/fieldset\";\nimport { font } from \"./tags/font\";\nimport { h, h1, h2, h3, h4, h5, h6, sh } from \"./tags/header\";\nimport { heightrestrict } from \"./tags/heightrestrict\";\nimport { highlight } from \"./tags/highlight\";\nimport { imagefloat } from \"./tags/imagefloat\";\nimport { justify } from \"./tags/justify\";\nimport { mail } from \"./tags/mail\";\nimport { newspaper } from \"./tags/newspaper\";\nimport { br, nobr } from \"./tags/lineBreak\";\nimport { note } from \"./tags/note\";\nimport { ooc } from \"./tags/ooc\";\nimport { pindent } from \"./tags/pindent\";\nimport { plain } from \"./tags/plain\";\nimport { print } from \"./tags/print\";\nimport { progress } from \"./tags/progress\";\nimport { thinprogress } from \"./tags/thinprogress\";\nimport { scroll } from \"./tags/scroll\";\nimport { side } from \"./tags/side\";\nimport { size } from \"./tags/size\";\nimport { sub } from \"./tags/subscript\";\nimport { sup } from \"./tags/superscript\";\nimport { inlinespoiler, spoiler } from \"./tags/spoiler\";\nimport { textmessage } from \"./tags/textmessage\";\nimport { tab, tabs } from \"./tags/tabs\";\nimport { accordionTags } from \"./tags/accordion\";\nimport { div } from \"./tags/div\";\nimport { classStyle } from \"./tags/class\";\nimport { script } from \"./tags/script\";\nimport { animation, keyframe } from \"./tags/animation\";\nimport { bold, italic, strike, underline } from \"./tags/discourse-core-replacement\";\n\nconst tags = {\n  ...accordionTags,\n  ...alignment,\n  ...anchor,\n  animation,\n  bg,\n  block,\n  blockquote,\n  border,\n  br,\n  centerblock,\n  check,\n  class: classStyle,\n  code,\n  color,\n  comment,\n  div,\n  divide,\n  fieldset,\n  font,\n  h,\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6,\n  heightrestrict,\n  highlight,\n  icode,\n  imagefloat,\n  inlinespoiler,\n  justify,\n  keyframe,\n  mail,\n  newspaper,\n  nobr,\n  note,\n  ooc,\n  pindent,\n  plain,\n  print,\n  progress,\n  thinprogress,\n  savenl,\n  sh,\n  script,\n  scroll,\n  side,\n  size,\n  spoiler,\n  sub,\n  sup,\n  tab,\n  tabs,\n  ...textmessage,\n\n  // discourse core replacement tags\n  b: bold,\n  i: italic,\n  u: underline,\n  s: strike,\n};\n\nconst availableTags = Object.keys(tags);\nconst preventParsing = [\"plain\", \"code\", \"icode\", \"class\"];\n\nconst preset = createPreset(tags);\n\nexport { availableTags, tags, preset, preventParsing };\nexport default preset;\n","import { preprocessAttr, toOriginalStartTag } from \"../utils/common\";\nimport { isStringNode, isTagNode } from \"@bbob/plugin-helper\";\n\n/**\n * Renders css Keyframes\n *\n * [animation=name][keyframe=0]color: red[/keyframe][/animation]\n */\nexport const animation = (node, options) => {\n  if (!options.data.previewing && !options.data.commonGUID) {\n    // create a common GUID for the post\n    // only applicable for div, style, and script tags\n    // this is to prevent the same class name from being used in different posts\n    options.data.commonGUID = \"post-\" + Math.random().toString(36).substring(2, 7);\n  }\n  const commonId = options.data.previewing ? \"preview\" : options.data.commonGUID;\n\n  const name = preprocessAttr(node.attrs)?._default || \"\";\n  const keyframes = node.content\n    .filter((n) => isTagNode(n) && n.tag === \"keyframe\")\n    .map((content) => {\n      content.isValid = true;\n      /** @type {string} */\n      const ident = preprocessAttr(content.attrs)._default || \"\";\n      content.ident = ident + (ident.match(/^\\d+$/) ? \"%\" : \"\");\n      const cleanContent = content.content\n        .filter(isStringNode)\n        .join(\"\")\n        .replaceAll(/[\\[\\]\\{\\}]/g, \"\");\n      content.formatted = `${content.ident}{ ${cleanContent} }`;\n      return content;\n    });\n  const keyframeContent = keyframes.map((n) => n.formatted).join(\"\\n\");\n  const content = `@keyframes ${commonId}${name} { ${keyframeContent} }`;\n  options.data.styles.push(content);\n  return [];\n};\n\nexport const keyframe = (node) => {\n  if (!node.isValid) {\n    return [toOriginalStartTag(node), ...node.content, node.toTagEnd()];\n  }\n  return [];\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * Add [bg] tag\n * @example [bg=red]Hello[/bg]\n */\nexport const bg = (node) => {\n  const color = preprocessAttr(node.attrs)._default;\n  return toNode(\n    \"div\",\n    {\n      style: `background-color: ${color};`,\n      class: \"bb-background\",\n    },\n    node.content,\n  );\n};\n","\nimport { preprocessAttr } from \"../utils/common\";\n\n\n/**\n * Add [block] tag\n * @example [block=treasure]content[/block]\n */\nexport const block = (node) => {\n    const defaultOp = \"block\";\n    const blockAttr = (preprocessAttr(node.attrs)._default || defaultOp).toLowerCase();\n\n    const OPTIONS = [\n        \"block\",\n        \"dice\",\n        \"dice10\",\n        \"setting\",\n        \"warning\",\n        \"storyteller\",\n        \"announcement\",\n        \"important\",\n        \"question\",\n        \"encounter\",\n        \"information\",\n        \"character\",\n        \"treasure\",\n    ];\n\n    // Default to block option if user did not provide anything valid\n    const blockOption = OPTIONS.includes(blockAttr) ? blockAttr : defaultOp;\n\n    return {\n        tag: \"table\",\n        attrs: {\n        class: \"bb-block\",\n        \"data-bb-block\": blockOption\n        },\n        content: [\n        {\n            tag: \"tbody\",\n            content: [\n            {\n                tag: \"tr\",\n                content: [\n                {\n                    tag: \"td\",\n                    attrs: {\n                    class: \"bb-block-icon\"\n                    }\n                },\n                {\n                    tag: \"td\",\n                    attrs: {\n                    class: \"bb-block-content\"\n                    },\n                    content: node.content\n                }\n                ]\n            }\n            ]\n        }\n        ]\n    };\n};","import { preprocessAttr } from \"../utils/common\";\n\n/**\n * @file Adds [blockquote] to bbcode\n * @example [blockquote=author]content[/blockquote]\n */\nexport const blockquote = (node) => {\n  const author = preprocessAttr(node.attrs)._default || \"\";\n\n  return {\n    tag: \"div\",\n    attrs: {\n      class: \"bb-blockquote\",\n    },\n    content: [\n      {\n        tag: \"div\",\n        attrs: {\n          class: \"bb-blockquote-left\",\n        },\n      },\n      {\n        tag: \"div\",\n        attrs: {\n          class: \"bb-blockquote-content\",\n        },\n        content: [\n          node.content,\n          {\n            tag: \"div\",\n            attrs: {\n              class: \"bb-blockquote-speaker\",\n            },\n            content: `${author !== \"\" ? `- ${author}` : \"\"}`,\n          },\n        ],\n      },\n      {\n        tag: \"div\",\n        attrs: {\n          class: \"bb-blockquote-right\",\n        },\n      },\n    ],\n  };\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\nexport const border = (node) => {\n  const val = preprocessAttr(node.attrs)._default;\n  return toNode(\n    \"div\",\n    {\n      style: `border: ${val};`,\n      class: \"bb-border\",\n    },\n    node.content\n  );\n};\n","import { toNode } from \"../utils/common\";\n\n/**\n * Creates a line break html <br/> tag\n */\nexport const br = () => {\n  return toNode(\"br\", {}, null);\n};\n\n/**\n * Disables line breaks for given content\n * @example\n * ```\n * [nobr]test\n * test\n * test\n * [/nobr]\n *\n * test test test\n * ```\n */\nexport const nobr = (node) => {\n  return { disableLineBreakConversion: true, content: node.content };\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\nexport const centerblock = (node) => {\n  const percentageInput = preprocessAttr(node.attrs)._default || \"50\";\n  return toNode(\"div\", { style: `margin: 0 auto; width: ${percentageInput}%` }, node.content);\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\nexport const check = (node) => {\n  const attrs = preprocessAttr(node.attrs)._default || \"dot\";\n  return toNode(\"div\", { class: `bb-check`, \"data-type\": attrs }, node.content);\n};\n","import { isStringNode } from \"@bbob/plugin-helper\";\nimport { preprocessAttr } from \"../utils/common\";\n\n/**\n * Class style tag\n *\n * [class=name]content[/class]\n * [class name=\"className\" state=\"psuedo-class\" minWidth=\"\" maxWidth=\"\"]content[/class]\n * [class name=\"className\" selector=\"\"]content[/class]\n */\nexport const classStyle = (node, options) => {\n  const attrs = preprocessAttr(node.attrs);\n  const nameAttr = attrs.name || attrs._default;\n\n  if (!options.data.previewing && !options.data.commonGUID) {\n    // create a common GUID for the post\n    // only applicable for div, style, and script tags\n    // this is to prevent the same class name from being used in different posts\n    options.data.commonGUID = \"post-\" + Math.random().toString(36).substring(2, 7);\n  }\n  const classSuffix = options.data.previewing ? \"preview\" : options.data.commonGUID;\n  const className = nameAttr + \"__\" + classSuffix;\n  const content = node.content\n    .filter(isStringNode)\n    .map((s) => s.replaceAll(\"{post_id}\", classSuffix).replaceAll(/[\\[\\]\\{\\}]/g, \"\"));\n  let selector = \"\";\n  const mediaQuery = [];\n  if (\n    [\"hover\", \"focus\", \"active\", \"focus-within\", \"focus-visible\"].includes(\n      attrs.state?.toLowerCase(),\n    )\n  ) {\n    selector = \":\" + attrs.state.toLowerCase();\n  }\n  if (attrs.selector) {\n    selector = attrs.selector.replace(/[,{}\\\\\\n]/g, \"\");\n  }\n  if (attrs.minWidth?.match(/^[0-9]+[a-z]+$/)) {\n    // @media (min-width: )\n    mediaQuery.push(`(min-width: ${attrs.minWidth})`);\n  }\n  if (attrs.maxWidth?.match(/^[0-9]+[a-z]+$/)) {\n    // @media (max-width: )\n    mediaQuery.push(`(max-width: ${attrs.maxWidth})`);\n  }\n\n  content.unshift(`.${className}${selector} {`);\n  content.push(\"}\");\n  if (mediaQuery.length) {\n    content.unshift(`@media ${mediaQuery.join(\" and \")} {`);\n    content.push(\"}\");\n  }\n  options.data.styles.push(content.join(\"\"));\n\n  return [];\n};\n","import { preprocessAttr } from \"../utils/common\";\n\n/**\n * processes [code] tag and returns a fenced code block\n */\nexport const code = (node) => {\n  const lang = preprocessAttr(node.attrs)._default || \"bbcode\";\n  return {\n    isWhitespaceSensitive: true,\n    content: [\"```\" + lang + \"\\n\", node.content, \"\\n```\\n\"],\n  };\n};\n\n/**\n * processes [icode] tag and returns inline code\n */\nexport const icode = (node) => {\n  return {\n    isWhitespaceSensitive: true,\n    content: [\"`\", node.content, \"`\"],\n  };\n};\n\n/**\n * Special tag to save newlines in code blocks. Used for hoisting code blocks\n */\nexport const savenl = (node) => {\n  return {\n    isWhitespaceSensitive: true,\n    content: node.content,\n  };\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\nexport const color = (node) => {\n  const inputColor = preprocessAttr(node.attrs)._default || \"\";\n  if (inputColor.trim() === \"\") {\n    return node.content;\n  }\n  return toNode(\"span\", { style: `color: ${inputColor}` }, node.content);\n};\n","import { toNode } from \"../utils/common\";\n\n/**\n * @file Adds [comment] tag\n * @example [comment]Content[/comment]\n */\n\nconst comment = (node) => {\n  return toNode(\"span\", { class: \"hidden\" }, node.content);\n};\n\nexport { comment };\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * Adds [div] tag\n * [div=css]Content[/div]\n * [div class=\"class\" style=\"css\"]Content[/div]\n */\nexport const div = (node, options) => {\n  const attrs = preprocessAttr(node.attrs);\n  const style = attrs.style || attrs._default;\n  const classAttrs = attrs.class;\n\n  if (!classAttrs?.trim()) {\n    return toNode(\n      \"div\",\n      {\n        style,\n      },\n      node.content,\n    );\n  }\n\n  if (!options.data.previewing && !options.data.commonGUID) {\n    // create a common GUID for the post\n    // only applicable for div, style, and script tags\n    // this is to prevent the same class name from being used in different posts\n    options.data.commonGUID = \"post-\" + Math.random().toString(36).substring(2, 7);\n  }\n  const classSuffix = options.data.previewing ? \"preview\" : options.data.commonGUID;\n  const classNames = classAttrs\n    .split(\" \")\n    .map((c) => c + \"__\" + classSuffix)\n    .join(\" \");\n\n  return toNode(\n    \"div\",\n    {\n      class: classNames,\n      style,\n    },\n    node.content,\n  );\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\nexport const divide = (node) => {\n  const type = (preprocessAttr(node.attrs)._default || \"\").toLowerCase();\n  return toNode(\n    \"span\",\n    {\n      class: \"bb-divide\",\n      \"data-type\": type,\n    },\n    node.content\n  );\n};\n","import { preprocessAttr } from \"../utils/common\";\n\n/**\n * @file Adds [fieldset] to bbcode\n * @example [fieldset=title]content[/fieldset]\n */\nexport const fieldset = (node) => {\n  const title = preprocessAttr(node.attrs)._default || \"\";\n  return {\n    tag: \"fieldset\",\n    attrs: {\n      class: \"bb-fieldset\",\n    },\n    content: [\n      {\n        tag: \"legend\",\n        attrs: {\n          class: \"bb-fieldset-legend\",\n        },\n        content: title,\n      },\n      {\n        tag: \"div\",\n        attrs: {\n          class: \"bb-fieldset\",\n        },\n        content: node.content,\n      },\n    ],\n  };\n};\n","import { toNode } from \"../utils/common\";\n\n/**\n * @file Adds Header to bbcode\n * @example [h]content[/h], [h2]content[/h2], [h3]content[/h3],\n * [h4]content[/h4], [h5]content[/h5], [h6]content[/h6].\n */\n\nconst h = (node) => {\n  return toNode(\"h1\", {}, node.content);\n};\n\nconst h1 = (node) => {\n  return toNode(\"h1\", {}, node.content);\n};\n\nconst h2 = (node) => {\n  return toNode(\"h2\", {}, node.content);\n};\n\nconst sh = (node) => {\n  return toNode(\"h2\", {}, node.content);\n};\n\nconst h3 = (node) => {\n  return toNode(\"h3\", {}, node.content);\n};\n\nconst h4 = (node) => {\n  return toNode(\"h4\", {}, node.content);\n};\n\nconst h5 = (node) => {\n  return toNode(\"h5\", {}, node.content);\n};\n\nconst h6 = (node) => {\n  return toNode(\"h6\", {}, node.content);\n};\n\nexport { h, sh, h1, h2, h3, h4, h5, h6 };\n","import { toNode } from \"../utils/common\";\n/**\n * @file Adds [highlight] to bbcode\n * @example [highlight]content[/highlight]\n */\nexport const highlight = (node) => {\n  return toNode(\"span\", { class: \"bb-highlight\" }, node.content);\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n/**\n * @file Adds [imagefloat] to bbcode\n * @exmaple [imagefloat=left]content[/imagefloat]\n */\nexport const imagefloat = (node) => {\n  const attrs = preprocessAttr(node.attrs)._default || \"\";\n  return toNode(\"div\", { class: `bb-float-${attrs}` }, node.content);\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n/**\n * @file Adds [spoiler] and [inlinespoiler] to bbcode\n *\n * Defaults to \"Spoiler\" name if no title provided\n *\n * @example `[spoiler=Title]text[/spoiler]`\n * @example `[inlinespoiler]hidden content[/inlinespoiler]\n */\n\nexport const spoiler = (node) => {\n  const providedTitle = preprocessAttr(node.attrs)._default;\n  const title = \"Spoiler\" + (providedTitle ? `: ${providedTitle}` : \"\");\n\n  /**\n   * <details class=\"bb-spoiler\">\n   *  <summary>Title</summary>\n   *  <div class=\"bb-spoiler-content\">\n   *    lorem ipsum\n   *  </div>\n   * </details>\n   */\n  return {\n    tag: \"details\",\n    attrs: {\n      class: \"bb-spoiler\",\n    },\n    content: [\n      {\n        tag: \"summary\",\n        content: title,\n      },\n      {\n        tag: \"div\",\n        attrs: {\n          class: \"bb-spoiler-content\",\n        },\n        content: node.content,\n      },\n    ],\n  };\n};\n\nexport const inlinespoiler = (node) => {\n  return toNode(\"span\", { class: \"bb-inline-spoiler\" }, node.content);\n};\n","import { toNode } from \"../utils/common\";\n\n/**\n * @file Adds [justify] to bbcode\n * @example [justify]content[/justify]\n */\nexport const justify = (node) => {\n  return toNode(\"div\", { class: \"bb-justify\" }, node.content);\n};\n","import { toNode } from \"../utils/common\";\n/**\n * @file Adds [newspaper] to bbcode\n * @example [newspaper]content[/newspaper]\n */\nexport const newspaper = (node) => {\n  return toNode(\"div\", { class: \"bb-newspaper\" }, node.content);\n};\n","import { toNode } from \"../utils/common\";\n/**\n * @file Adds [note] to bbcode\n * @example [note]content[/note]\n */\n\nexport const note = (node) => {\n  return toNode(\"div\", { class: \"bb-note\" }, [\n    toNode(\"div\", { class: \"bb-note-tape\" }, \"\"),\n    toNode(\"div\", { class: \"bb-note-content\" }, [\n      node.content,\n      toNode(\"div\", { class: \"bb-note-footer\" }, \"\"),\n    ]),\n  ]);\n};\n","import { toNode } from \"../utils/common\";\n\n/**\n * @file Adds [ooc] to bbcode\n * @example [ooc]content[/ooc]\n */\nexport const ooc = (node) => {\n  return toNode(\n    \"div\",\n    {\n      class: \"bb-ooc\",\n    },\n    node.content,\n  );\n};\n","import { toNode } from \"../utils/common\";\n/**\n * @file Adds [pindent] to bbcode\n * @example [pindent]content[/pindent]\n */\nexport const pindent = (node) => {\n  return toNode(\"span\", { class: \"bb-pindent\" }, node.content);\n};\n","/**\n * [plain] bbcode tag that prevents parsing of inner tags\n * @example\n * ```\n * [plain]This is [b]bold[/b] and [i]italic[/i][/plain]\n * ```\n * outputs to\n * ```\n * This is [b]bold[/b] and [i]italic[/i]\n * ```\n */\nexport const plain = (node) => {\n  return node.content;\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * Add [print] tag\n * @example [print=lined]content[/print]\n */\nexport const print = (node) => {\n  const defaultOp = \"print\";\n  const printAttr = (preprocessAttr(node.attrs)._default || defaultOp).toLowerCase();\n\n  const OPTIONS = [\"print\", \"line\", \"graph\", \"parchment\"];\n\n  // Default to print if option is not valid\n  const printOption = OPTIONS.includes(printAttr) ? printAttr : defaultOp;\n\n  return toNode(\n    \"div\",\n    { class: printOption === defaultOp ? `bb-print` : `bb-print-${printOption}` },\n    node.content,\n  );\n};\n","import { preprocessAttr } from \"../utils/common\";\n\n/**\n * @file Adds [progress] to bbcode\n * @exmaple [progress=percentageInt]content[/progress]\n */\nexport const progress = (node) => {\n  const percentageInt = preprocessAttr(node.attrs)._default;\n  return {\n    tag: \"div\",\n    attrs: {\n      class: \"bb-progress\",\n    },\n    content: [\n      {\n        tag: \"div\",\n        attrs: {\n          class: \"bb-progress-text\",\n        },\n        content: node.content,\n      },\n      {\n        tag: \"div\",\n        attrs: {\n          class: \"bb-progress-bar\",\n          style: `width: calc(${percentageInt}% - 6px)`,\n        },\n      },\n      {\n        tag: \"div\",\n        attrs: {\n          class: \"bb-progress-bar-other\",\n        },\n      },\n    ],\n  };\n};\n","\nimport { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * @file Adds [thinprogress] to bbcode\n * @exmaple [thinprogress=percentageInt]content[/progthinprogressress]\n */\nexport const thinprogress = (node) => {\n    const percentageInt = preprocessAttr(node.attrs)._default;\n    return {\n        tag: \"div\",\n        attrs: {\n          class: \"bb-progress-thin\",\n        },\n        content: [\n          {\n            tag: \"div\",\n            attrs: {\n              class: \"bb-progress-text\"\n            },\n            content: node.content\n          },\n          {\n            tag: \"div\",\n            attrs: {\n              class: \"bb-progress-bar\",\n              style: `width: calc(${percentageInt}% - 6px)`\n            }\n          },\n          {\n            tag: \"div\",\n            attrs: {\n              class: \"bb-progress-bar-other\"\n            }\n          }\n        ],\n      };\n}","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * Parse the user provided height and return a valid height value\n * @param {Number} heightValue obtains the input of the user entered height (default is 700)\n * @returns A validated number less than 0.\n */\nfunction parseHeight(heightValue) {\n  const maxHeight = 700;\n  const parsedHeight =\n    heightValue && heightValue.trim() !== \"\" ? heightValue.replace(/[^\\d.]/g, \"\") : 0;\n\n  if (parsedHeight && parsedHeight >= 0 && parsedHeight <= maxHeight) {\n    return parsedHeight;\n  } else {\n    // if the value = 0 then nothing will be returned\n    return parsedHeight === 0 ? 0 : maxHeight;\n  }\n}\n\n/**\n * @file Adds [scroll] to bbcode\n * @example [scroll]content[/scroll]\n */\nexport const scroll = (node) => {\n  const attrs = preprocessAttr(node.attrs)._default;\n  const heightInput = parseHeight(attrs);\n  return toNode(\"div\", { class: \"bb-scroll\", style: `height: ${heightInput}px` }, node.content);\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\nexport const side = (node) => {\n  const attrs = preprocessAttr(node.attrs)._default || \"left\";\n  return toNode(\"div\", { class: \"bb-side\", \"data-side\": attrs }, node.content);\n};\n","import { toNode } from \"../utils/common\";\n\n/**\n * @file Adds subscript to BBCode\n * @example [sub]content[/sub]\n */\n\nconst sub = (node) => {\n  return toNode(\"sub\", {}, node.content);\n};\n\nexport { sub };\n","import { toNode } from \"../utils/common\";\n\n/**\n * @file Adds superscript to bbcode\n * @example [sup]content[/sup]\n */\n\nconst sup = (node) => {\n  return toNode(\"sup\", {}, node.content);\n};\n\nexport { sup };\n","/**\n * @file discourse-core-replacement.js\n * This is a dedicated file for replacing the standard Discourse BBCode tags in core.\n * In the markdown-it engine, discourse has added these bbcode tags in the inline parser.\n * However this means that if the parser detects a block level tag inside an inline tag,\n * it will not parse the inline tag.\n *\n * This file is meant to fix such scenarios by doing the parsing of bbcode tags for it.\n *\n * @example\n * [b][h]bold[/h][/b]   // this should properly parse the bold tag inside the h tag\n *\n * https://github.com/discourse/discourse/blob/d7ece61252d7671a1f124483836279b99852c08c/app/assets/javascripts/discourse-markdown-it/src/features/bbcode-inline.js\n */\nimport { toNode } from \"../utils/common\";\n\nexport const bold = (node) => {\n  return toNode(\"span\", { class: \"bbcode-b\" }, node.content);\n};\n\nexport const italic = (node) => {\n  return toNode(\"span\", { class: \"bbcode-i\" }, node.content);\n};\n\nexport const underline = (node) => {\n  return toNode(\"span\", { class: \"bbcode-u\" }, node.content);\n};\n\nexport const strike = (node) => {\n  return toNode(\"span\", { class: \"bbcode-s\" }, node.content);\n};\n","import { OPEN_BRAKET, CLOSE_BRAKET, SLASH } from '@bbob/plugin-helper';\n// type, value, line, row,\nconst TOKEN_TYPE_ID = 'type'; // 0;\nconst TOKEN_VALUE_ID = 'value'; // 1;\nconst TOKEN_COLUMN_ID = 'row'; // 2;\nconst TOKEN_LINE_ID = 'line'; // 3;\nconst TOKEN_TYPE_WORD = 1; // 'word';\nconst TOKEN_TYPE_TAG = 2; // 'tag';\nconst TOKEN_TYPE_ATTR_NAME = 3; // 'attr-name';\nconst TOKEN_TYPE_ATTR_VALUE = 4; // 'attr-value';\nconst TOKEN_TYPE_SPACE = 5; // 'space';\nconst TOKEN_TYPE_NEW_LINE = 6; // 'new-line';\n/**\n * @param {Token} token\n * @returns {string}\n */ const getTokenValue = (token)=>{\n    if (token && typeof token[TOKEN_VALUE_ID] !== 'undefined') {\n        return token[TOKEN_VALUE_ID];\n    }\n    return '';\n};\n/**\n * @param {Token}token\n * @returns {number}\n */ const getTokenLine = (token)=>token && token[TOKEN_LINE_ID] || 0;\nconst getTokenColumn = (token)=>token && token[TOKEN_COLUMN_ID] || 0;\n/**\n * @param {Token} token\n * @returns {boolean}\n */ const isTextToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_SPACE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_NEW_LINE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_WORD;\n    }\n    return false;\n};\n/**\n * @param {Token} token\n * @returns {boolean}\n */ const isTagToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_TAG;\n    }\n    return false;\n};\nconst isTagEnd = (token)=>getTokenValue(token).charCodeAt(0) === SLASH.charCodeAt(0);\nconst isTagStart = (token)=>!isTagEnd(token);\nconst isAttrNameToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_NAME;\n    }\n    return false;\n};\n/**\n * @param {Token} token\n * @returns {boolean}\n */ const isAttrValueToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_VALUE;\n    }\n    return false;\n};\nconst getTagName = (token)=>{\n    const value = getTokenValue(token);\n    return isTagEnd(token) ? value.slice(1) : value;\n};\nconst convertTagToText = (token)=>{\n    let text = OPEN_BRAKET;\n    text += getTokenValue(token);\n    text += CLOSE_BRAKET;\n    return text;\n};\nclass Token {\n    isEmpty() {\n        // eslint-disable-next-line no-restricted-globals\n        return isNaN(this[TOKEN_TYPE_ID]);\n    }\n    isText() {\n        return isTextToken(this);\n    }\n    isTag() {\n        return isTagToken(this);\n    }\n    isAttrName() {\n        return isAttrNameToken(this);\n    }\n    isAttrValue() {\n        return isAttrValueToken(this);\n    }\n    isStart() {\n        return isTagStart(this);\n    }\n    isEnd() {\n        return isTagEnd(this);\n    }\n    getName() {\n        return getTagName(this);\n    }\n    getValue() {\n        return getTokenValue(this);\n    }\n    getLine() {\n        return getTokenLine(this);\n    }\n    getColumn() {\n        return getTokenColumn(this);\n    }\n    toString() {\n        return convertTagToText(this);\n    }\n    /**\n   * @param {String} type\n   * @param {String} value\n   * @param line\n   * @param row\n   */ constructor(type, value, line, row){\n        this[TOKEN_TYPE_ID] = Number(type);\n        this[TOKEN_VALUE_ID] = String(value);\n        this[TOKEN_LINE_ID] = Number(line);\n        this[TOKEN_COLUMN_ID] = Number(row);\n    }\n}\nexport const TYPE_ID = TOKEN_TYPE_ID;\nexport const VALUE_ID = TOKEN_VALUE_ID;\nexport const LINE_ID = TOKEN_LINE_ID;\nexport const COLUMN_ID = TOKEN_COLUMN_ID;\nexport const TYPE_WORD = TOKEN_TYPE_WORD;\nexport const TYPE_TAG = TOKEN_TYPE_TAG;\nexport const TYPE_ATTR_NAME = TOKEN_TYPE_ATTR_NAME;\nexport const TYPE_ATTR_VALUE = TOKEN_TYPE_ATTR_VALUE;\nexport const TYPE_SPACE = TOKEN_TYPE_SPACE;\nexport const TYPE_NEW_LINE = TOKEN_TYPE_NEW_LINE;\nexport { Token };\nexport default Token;\n","import { QUOTEMARK, BACKSLASH } from '@bbob/plugin-helper';\nfunction CharGrabber(source, options) {\n    const cursor = {\n        pos: 0,\n        len: source.length\n    };\n    const substrUntilChar = (char)=>{\n        const { pos  } = cursor;\n        const idx = source.indexOf(char, pos);\n        return idx >= 0 ? source.substring(pos, idx) : '';\n    };\n    const includes = (val)=>source.indexOf(val, cursor.pos) >= 0;\n    const hasNext = ()=>cursor.len > cursor.pos;\n    const isLast = ()=>cursor.pos === cursor.len;\n    const skip = (num = 1, silent)=>{\n        cursor.pos += num;\n        if (options && options.onSkip && !silent) {\n            options.onSkip();\n        }\n    };\n    const rest = ()=>source.substring(cursor.pos);\n    const grabN = (num = 0)=>source.substring(cursor.pos, cursor.pos + num);\n    const curr = ()=>source[cursor.pos];\n    const prev = ()=>{\n        const prevPos = cursor.pos - 1;\n        return typeof source[prevPos] !== 'undefined' ? source[prevPos] : null;\n    };\n    const next = ()=>{\n        const nextPos = cursor.pos + 1;\n        return nextPos <= source.length - 1 ? source[nextPos] : null;\n    };\n    const grabWhile = (cond, silent)=>{\n        let start = 0;\n        if (hasNext()) {\n            start = cursor.pos;\n            while(hasNext() && cond(curr())){\n                skip(1, silent);\n            }\n        }\n        return source.substring(start, cursor.pos);\n    };\n    /**\n   * @type {skip}\n   */ this.skip = skip;\n    /**\n   * @returns {Boolean}\n   */ this.hasNext = hasNext;\n    /**\n   * @returns {String}\n   */ this.getCurr = curr;\n    /**\n   * @returns {String}\n   */ this.getRest = rest;\n    /**\n   * @returns {String}\n   */ this.getNext = next;\n    /**\n   * @returns {String}\n   */ this.getPrev = prev;\n    /**\n   * @returns {Boolean}\n   */ this.isLast = isLast;\n    /**\n   * @returns {Boolean}\n   */ this.includes = includes;\n    /**\n   * @param {Function} cond\n   * @param {Boolean} silent\n   * @return {String}\n   */ this.grabWhile = grabWhile;\n    /**\n   * @param {Number} num\n   * @return {String}\n   */ this.grabN = grabN;\n    /**\n   * Grabs rest of string until it find a char\n   * @param {String} char\n   * @return {String}\n   */ this.substrUntilChar = substrUntilChar;\n}\n/**\n * Creates a grabber wrapper for source string, that helps to iterate over string char by char\n * @param {String} source\n * @param {Object} options\n * @param {Function} options.onSkip\n * @return CharGrabber\n */ export const createCharGrabber = (source, options)=>new CharGrabber(source, options);\n/**\n * Trims string from start and end by char\n * @example\n *  trimChar('*hello*', '*') ==> 'hello'\n * @param {String} str\n * @param {String} charToRemove\n * @returns {String}\n */ export const trimChar = (str, charToRemove)=>{\n    while(str.charAt(0) === charToRemove){\n        // eslint-disable-next-line no-param-reassign\n        str = str.substring(1);\n    }\n    while(str.charAt(str.length - 1) === charToRemove){\n        // eslint-disable-next-line no-param-reassign\n        str = str.substring(0, str.length - 1);\n    }\n    return str;\n};\n/**\n * Unquotes \\\" to \"\n * @param str\n * @return {String}\n */ export const unquote = (str)=>str.replace(BACKSLASH + QUOTEMARK, QUOTEMARK);\nfunction NodeList(values = []) {\n    const nodes = values;\n    const getLast = ()=>Array.isArray(nodes) && nodes.length > 0 && typeof nodes[nodes.length - 1] !== 'undefined' ? nodes[nodes.length - 1] : null;\n    const flushLast = ()=>nodes.length ? nodes.pop() : false;\n    const push = (value)=>nodes.push(value);\n    const toArray = ()=>nodes;\n    this.push = push;\n    this.toArray = toArray;\n    this.getLast = getLast;\n    this.flushLast = flushLast;\n}\n/**\n *\n * @param values\n * @return {NodeList}\n */ export const createList = (values = [])=>new NodeList(values);\n","/* eslint-disable no-plusplus,no-param-reassign */ import { OPEN_BRAKET, CLOSE_BRAKET, QUOTEMARK, BACKSLASH, SLASH, SPACE, TAB, EQ, N } from '@bbob/plugin-helper';\nimport { Token, TYPE_ATTR_NAME, TYPE_ATTR_VALUE, TYPE_NEW_LINE, TYPE_SPACE, TYPE_TAG, TYPE_WORD } from './Token';\nimport { createCharGrabber, trimChar, unquote } from './utils';\n// for cases <!-- -->\nconst EM = '!';\n/**\n * Creates a Token entity class\n * @param {Number} type\n * @param {String} value\n * @param {Number} r line number\n * @param {Number} cl char number in line\n */ const createToken = (type, value, r = 0, cl = 0)=>new Token(type, value, r, cl);\n/**\n * @typedef {Object} Lexer\n * @property {Function} tokenize\n * @property {Function} isTokenNested\n */ /**\n * @param {String} buffer\n * @param {Object} options\n * @param {Function} options.onToken\n * @param {String} options.openTag\n * @param {String} options.closeTag\n * @param {Boolean} options.enableEscapeTags\n * @return {Lexer}\n */ function createLexer(buffer, options = {}) {\n    const STATE_WORD = 0;\n    const STATE_TAG = 1;\n    const STATE_TAG_ATTRS = 2;\n    const TAG_STATE_NAME = 0;\n    const TAG_STATE_ATTR = 1;\n    const TAG_STATE_VALUE = 2;\n    let row = 0;\n    let col = 0;\n    let tokenIndex = -1;\n    let stateMode = STATE_WORD;\n    let tagMode = TAG_STATE_NAME;\n    let contextFreeTag = '';\n    const tokens = new Array(Math.floor(buffer.length));\n    const openTag = options.openTag || OPEN_BRAKET;\n    const closeTag = options.closeTag || CLOSE_BRAKET;\n    const escapeTags = !!options.enableEscapeTags;\n    const contextFreeTags = options.contextFreeTags || [];\n    const onToken = options.onToken || (()=>{});\n    const RESERVED_CHARS = [\n        closeTag,\n        openTag,\n        QUOTEMARK,\n        BACKSLASH,\n        SPACE,\n        TAB,\n        EQ,\n        N,\n        EM\n    ];\n    const NOT_CHAR_TOKENS = [\n        openTag,\n        SPACE,\n        TAB,\n        N\n    ];\n    const WHITESPACES = [\n        SPACE,\n        TAB\n    ];\n    const SPECIAL_CHARS = [\n        EQ,\n        SPACE,\n        TAB\n    ];\n    const isCharReserved = (char)=>RESERVED_CHARS.indexOf(char) >= 0;\n    const isNewLine = (char)=>char === N;\n    const isWhiteSpace = (char)=>WHITESPACES.indexOf(char) >= 0;\n    const isCharToken = (char)=>NOT_CHAR_TOKENS.indexOf(char) === -1;\n    const isSpecialChar = (char)=>SPECIAL_CHARS.indexOf(char) >= 0;\n    const isEscapableChar = (char)=>char === openTag || char === closeTag || char === BACKSLASH;\n    const isEscapeChar = (char)=>char === BACKSLASH;\n    const onSkip = ()=>{\n        col++;\n    };\n    const unq = (val)=>unquote(trimChar(val, QUOTEMARK));\n    const checkContextFreeMode = (name, isClosingTag)=>{\n        if (contextFreeTag !== '' && isClosingTag) {\n            contextFreeTag = '';\n        }\n        if (contextFreeTag === '' && contextFreeTags.includes(name)) {\n            contextFreeTag = name;\n        }\n    };\n    const chars = createCharGrabber(buffer, {\n        onSkip\n    });\n    /**\n   * Emits newly created token to subscriber\n   * @param {Number} type\n   * @param {String} value\n   */ function emitToken(type, value) {\n        const token = createToken(type, value, row, col);\n        onToken(token);\n        tokenIndex += 1;\n        tokens[tokenIndex] = token;\n    }\n    function nextTagState(tagChars, isSingleValueTag) {\n        if (tagMode === TAG_STATE_ATTR) {\n            const validAttrName = (char)=>!(char === EQ || isWhiteSpace(char));\n            const name = tagChars.grabWhile(validAttrName);\n            const isEnd = tagChars.isLast();\n            const isValue = tagChars.getCurr() !== EQ;\n            tagChars.skip();\n            if (isEnd || isValue) {\n                emitToken(TYPE_ATTR_VALUE, unq(name));\n            } else {\n                emitToken(TYPE_ATTR_NAME, name);\n            }\n            if (isEnd) {\n                return TAG_STATE_NAME;\n            }\n            if (isValue) {\n                return TAG_STATE_ATTR;\n            }\n            return TAG_STATE_VALUE;\n        }\n        if (tagMode === TAG_STATE_VALUE) {\n            let stateSpecial = false;\n            const validAttrValue = (char)=>{\n                // const isEQ = char === EQ;\n                const isQM = char === QUOTEMARK;\n                const prevChar = tagChars.getPrev();\n                const nextChar = tagChars.getNext();\n                const isPrevSLASH = prevChar === BACKSLASH;\n                const isNextEQ = nextChar === EQ;\n                const isWS = isWhiteSpace(char);\n                // const isPrevWS = isWhiteSpace(prevChar);\n                const isNextWS = isWhiteSpace(nextChar);\n                if (stateSpecial && isSpecialChar(char)) {\n                    return true;\n                }\n                if (isQM && !isPrevSLASH) {\n                    stateSpecial = !stateSpecial;\n                    if (!stateSpecial && !(isNextEQ || isNextWS)) {\n                        return false;\n                    }\n                }\n                if (!isSingleValueTag) {\n                    return isWS === false;\n                // return (isEQ || isWS) === false;\n                }\n                return true;\n            };\n            const name1 = tagChars.grabWhile(validAttrValue);\n            tagChars.skip();\n            emitToken(TYPE_ATTR_VALUE, unq(name1));\n            if (tagChars.isLast()) {\n                return TAG_STATE_NAME;\n            }\n            return TAG_STATE_ATTR;\n        }\n        const validName = (char)=>!(char === EQ || isWhiteSpace(char) || tagChars.isLast());\n        const name2 = tagChars.grabWhile(validName);\n        emitToken(TYPE_TAG, name2);\n        checkContextFreeMode(name2);\n        tagChars.skip();\n        // in cases when we has [url=someval]GET[/url] and we dont need to parse all\n        if (isSingleValueTag) {\n            return TAG_STATE_VALUE;\n        }\n        const hasEQ = tagChars.includes(EQ);\n        return hasEQ ? TAG_STATE_ATTR : TAG_STATE_VALUE;\n    }\n    function stateTag() {\n        const currChar = chars.getCurr();\n        const nextChar = chars.getNext();\n        chars.skip();\n        // detect case where we have '[My word [tag][/tag]' or we have '[My last line word'\n        const substr = chars.substrUntilChar(closeTag);\n        const hasInvalidChars = substr.length === 0 || substr.indexOf(openTag) >= 0;\n        if (isCharReserved(nextChar) || hasInvalidChars || chars.isLast()) {\n            emitToken(TYPE_WORD, currChar);\n            return STATE_WORD;\n        }\n        // [myTag   ]\n        const isNoAttrsInTag = substr.indexOf(EQ) === -1;\n        // [/myTag]\n        const isClosingTag = substr[0] === SLASH;\n        if (isNoAttrsInTag || isClosingTag) {\n            const name = chars.grabWhile((char)=>char !== closeTag);\n            chars.skip(); // skip closeTag\n            emitToken(TYPE_TAG, name);\n            checkContextFreeMode(name, isClosingTag);\n            return STATE_WORD;\n        }\n        return STATE_TAG_ATTRS;\n    }\n    function stateAttrs() {\n        const silent = true;\n        const tagStr = chars.grabWhile((char)=>char !== closeTag, silent);\n        const tagGrabber = createCharGrabber(tagStr, {\n            onSkip\n        });\n        const hasSpace = tagGrabber.includes(SPACE);\n        tagMode = TAG_STATE_NAME;\n        while(tagGrabber.hasNext()){\n            tagMode = nextTagState(tagGrabber, !hasSpace);\n        }\n        chars.skip(); // skip closeTag\n        return STATE_WORD;\n    }\n    function stateWord() {\n        if (isNewLine(chars.getCurr())) {\n            emitToken(TYPE_NEW_LINE, chars.getCurr());\n            chars.skip();\n            col = 0;\n            row++;\n            return STATE_WORD;\n        }\n        if (isWhiteSpace(chars.getCurr())) {\n            const word = chars.grabWhile(isWhiteSpace);\n            emitToken(TYPE_SPACE, word);\n            return STATE_WORD;\n        }\n        if (chars.getCurr() === openTag) {\n            if (contextFreeTag) {\n                const fullTagLen = openTag.length + SLASH.length + contextFreeTag.length;\n                const fullTagName = `${openTag}${SLASH}${contextFreeTag}`;\n                const foundTag = chars.grabN(fullTagLen);\n                const isEndContextFreeMode = foundTag === fullTagName;\n                if (isEndContextFreeMode) {\n                    return STATE_TAG;\n                }\n            } else if (chars.includes(closeTag)) {\n                return STATE_TAG;\n            }\n            emitToken(TYPE_WORD, chars.getCurr());\n            chars.skip();\n            return STATE_WORD;\n        }\n        if (escapeTags) {\n            if (isEscapeChar(chars.getCurr())) {\n                const currChar = chars.getCurr();\n                const nextChar = chars.getNext();\n                chars.skip(); // skip the \\ without emitting anything\n                if (isEscapableChar(nextChar)) {\n                    chars.skip(); // skip past the [, ] or \\ as well\n                    emitToken(TYPE_WORD, nextChar);\n                    return STATE_WORD;\n                }\n                emitToken(TYPE_WORD, currChar);\n                return STATE_WORD;\n            }\n            const isChar = (char)=>isCharToken(char) && !isEscapeChar(char);\n            const word1 = chars.grabWhile(isChar);\n            emitToken(TYPE_WORD, word1);\n            return STATE_WORD;\n        }\n        const word2 = chars.grabWhile(isCharToken);\n        emitToken(TYPE_WORD, word2);\n        return STATE_WORD;\n    }\n    function tokenize() {\n        stateMode = STATE_WORD;\n        while(chars.hasNext()){\n            switch(stateMode){\n                case STATE_TAG:\n                    stateMode = stateTag();\n                    break;\n                case STATE_TAG_ATTRS:\n                    stateMode = stateAttrs();\n                    break;\n                case STATE_WORD:\n                default:\n                    stateMode = stateWord();\n                    break;\n            }\n        }\n        tokens.length = tokenIndex + 1;\n        return tokens;\n    }\n    function isTokenNested(token) {\n        const value = openTag + SLASH + token.getValue();\n        // potential bottleneck\n        return buffer.indexOf(value) > -1;\n    }\n    return {\n        tokenize,\n        isTokenNested\n    };\n}\nexport const createTokenOfType = createToken;\nexport { createLexer };\n","import { TagNode, CLOSE_BRAKET, OPEN_BRAKET, isTagNode } from '@bbob/plugin-helper';\nimport { createLexer } from './lexer';\nimport { createList } from './utils';\n/**\n * @public\n * @param {string} input\n * @param {Object} opts\n * @param {Function} opts.createTokenizer\n * @param {Array<string>} opts.onlyAllowTags\n * @param {Array<string>} opts.contextFreeTags\n * @param {Boolean} opts.enableEscapeTags\n * @param {string} opts.openTag\n * @param {string} opts.closeTag\n * @return {Array<string|TagNode>}\n */ const parse = (input, opts = {})=>{\n    const options = opts;\n    const openTag = options.openTag || OPEN_BRAKET;\n    const closeTag = options.closeTag || CLOSE_BRAKET;\n    const onlyAllowTags = (options.onlyAllowTags || []).filter(Boolean).map((tag)=>tag.toLowerCase());\n    let tokenizer = null;\n    /**\n   * Result AST of nodes\n   * @private\n   * @type {NodeList}\n   */ const nodes = createList();\n    /**\n   * Temp buffer of nodes that's nested to another node\n   * @private\n   * @type {NodeList}\n   */ const nestedNodes = createList();\n    /**\n   * Temp buffer of nodes [tag..]...[/tag]\n   * @private\n   * @type {NodeList}\n   */ const tagNodes = createList();\n    /**\n   * Temp buffer of tag attributes\n   * @private\n   * @type {NodeList}\n   */ const tagNodesAttrName = createList();\n    /**\n   * Cache for nested tags checks\n   * @type Set<string>\n   */ const nestedTagsMap = new Set();\n    /**\n   * @param {Token} token\n   * @returns {boolean}\n   */ const isTokenNested = (token)=>{\n        const value = token.getValue();\n        if (!nestedTagsMap.has(value) && tokenizer.isTokenNested && tokenizer.isTokenNested(token)) {\n            nestedTagsMap.add(value);\n            return true;\n        }\n        return nestedTagsMap.has(value);\n    };\n    /**\n   * @private\n   * @param {string} tagName\n   * @returns {boolean}\n   */ const isTagNested = (tagName)=>Boolean(nestedTagsMap.has(tagName));\n    /**\n   * @private\n   * @param {string} value\n   * @return {boolean}\n   */ const isAllowedTag = (value)=>{\n        if (onlyAllowTags.length) {\n            return onlyAllowTags.indexOf(value.toLowerCase()) >= 0;\n        }\n        return true;\n    };\n    /**\n   * Flushes temp tag nodes and its attributes buffers\n   * @private\n   * @return {Array}\n   */ const flushTagNodes = ()=>{\n        if (tagNodes.flushLast()) {\n            tagNodesAttrName.flushLast();\n        }\n    };\n    /**\n   * @private\n   * @return {Array}\n   */ const getNodes = ()=>{\n        const lastNestedNode = nestedNodes.getLast();\n        if (lastNestedNode && Array.isArray(lastNestedNode.content)) {\n            return lastNestedNode.content;\n        }\n        return nodes.toArray();\n    };\n    /**\n   * @private\n   * @param {string|TagNode} node\n   * @param {boolean} isNested\n   */ const appendNodeAsString = (node, isNested = true)=>{\n        const items = getNodes();\n        if (Array.isArray(items)) {\n            items.push(node.toTagStart({\n                openTag,\n                closeTag\n            }));\n            if (node.content.length) {\n                node.content.forEach((item)=>{\n                    items.push(item);\n                });\n                if (isNested) {\n                    items.push(node.toTagEnd({\n                        openTag,\n                        closeTag\n                    }));\n                }\n            }\n        }\n    };\n    /**\n   * @private\n   * @param {string|TagNode} node\n   */ const appendNodes = (node)=>{\n        const items = getNodes();\n        if (Array.isArray(items)) {\n            if (isTagNode(node)) {\n                if (isAllowedTag(node.tag)) {\n                    items.push(node.toTagNode());\n                } else {\n                    appendNodeAsString(node);\n                }\n            } else {\n                items.push(node);\n            }\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const handleTagStart = (token)=>{\n        flushTagNodes();\n        const tagNode = TagNode.create(token.getValue());\n        const isNested = isTokenNested(token);\n        tagNodes.push(tagNode);\n        if (isNested) {\n            nestedNodes.push(tagNode);\n        } else {\n            appendNodes(tagNode, token);\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const handleTagEnd = (token)=>{\n        flushTagNodes();\n        const lastNestedNode = nestedNodes.flushLast();\n        if (lastNestedNode) {\n            appendNodes(lastNestedNode, token);\n        } else if (typeof options.onError === 'function') {\n            const tag = token.getValue();\n            const line = token.getLine();\n            const column = token.getColumn();\n            options.onError({\n                message: `Inconsistent tag '${tag}' on line ${line} and column ${column}`,\n                tagName: tag,\n                lineNumber: line,\n                columnNumber: column\n            });\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const handleTag = (token)=>{\n        // [tag]\n        if (token.isStart()) {\n            handleTagStart(token);\n        }\n        // [/tag]\n        if (token.isEnd()) {\n            handleTagEnd(token);\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const handleNode = (token)=>{\n        /**\n     * @type {TagNode}\n     */ const lastTagNode = tagNodes.getLast();\n        const tokenValue = token.getValue();\n        const isNested = isTagNested(token);\n        if (lastTagNode) {\n            if (token.isAttrName()) {\n                tagNodesAttrName.push(tokenValue);\n                lastTagNode.attr(tagNodesAttrName.getLast(), '');\n            } else if (token.isAttrValue()) {\n                const attrName = tagNodesAttrName.getLast();\n                if (attrName) {\n                    lastTagNode.attr(attrName, tokenValue);\n                    tagNodesAttrName.flushLast();\n                } else {\n                    lastTagNode.attr(tokenValue, tokenValue);\n                }\n            } else if (token.isText()) {\n                if (isNested) {\n                    lastTagNode.append(tokenValue);\n                } else {\n                    appendNodes(tokenValue);\n                }\n            } else if (token.isTag()) {\n                // if tag is not allowed, just past it as is\n                appendNodes(token.toString());\n            }\n        } else if (token.isText()) {\n            appendNodes(tokenValue);\n        } else if (token.isTag()) {\n            // if tag is not allowed, just past it as is\n            appendNodes(token.toString());\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const onToken = (token)=>{\n        if (token.isTag()) {\n            handleTag(token);\n        } else {\n            handleNode(token);\n        }\n    };\n    tokenizer = (opts.createTokenizer ? opts.createTokenizer : createLexer)(input, {\n        onToken,\n        openTag,\n        closeTag,\n        onlyAllowTags: options.onlyAllowTags,\n        contextFreeTags: options.contextFreeTags,\n        enableEscapeTags: options.enableEscapeTags\n    });\n    // eslint-disable-next-line no-unused-vars\n    const tokens = tokenizer.tokenize();\n    // handles situations where we open tag, but forgot close them\n    // for ex [q]test[/q][u]some[/u][q]some [u]some[/u] // forgot to close [/q]\n    // so we need to flush nested content to nodes array\n    const lastNestedNode = nestedNodes.flushLast();\n    if (lastNestedNode && isTagNested(lastNestedNode.tag)) {\n        appendNodeAsString(lastNestedNode, false);\n    }\n    return nodes.toArray();\n};\nexport { parse };\nexport default parse;\n","/* eslint-disable no-plusplus */ const isObj = (value)=>typeof value === 'object';\nconst isBool = (value)=>typeof value === 'boolean';\nexport function iterate(t, cb) {\n    const tree = t;\n    if (Array.isArray(tree)) {\n        for(let idx = 0; idx < tree.length; idx++){\n            tree[idx] = iterate(cb(tree[idx]), cb);\n        }\n    } else if (tree && isObj(tree) && tree.content) {\n        iterate(tree.content, cb);\n    }\n    return tree;\n}\nexport function same(expected, actual) {\n    if (typeof expected !== typeof actual) {\n        return false;\n    }\n    if (!isObj(expected) || expected === null) {\n        return expected === actual;\n    }\n    if (Array.isArray(expected)) {\n        return expected.every((exp)=>[].some.call(actual, (act)=>same(exp, act)));\n    }\n    return Object.keys(expected).every((key)=>{\n        const ao = actual[key];\n        const eo = expected[key];\n        if (isObj(eo) && eo !== null && ao !== null) {\n            return same(eo, ao);\n        }\n        if (isBool(eo)) {\n            return eo !== (ao === null);\n        }\n        return ao === eo;\n    });\n}\nexport function match(expression, cb) {\n    return Array.isArray(expression) ? iterate(this, (node)=>{\n        for(let idx = 0; idx < expression.length; idx++){\n            if (same(expression[idx], node)) {\n                return cb(node);\n            }\n        }\n        return node;\n    }) : iterate(this, (node)=>same(expression, node) ? cb(node) : node);\n}\n","import { parse } from '@bbob/parser';\nimport { iterate, match } from './utils';\nfunction walk(cb) {\n    return iterate(this, cb);\n}\nexport default function bbob(plugs) {\n    const plugins = typeof plugs === 'function' ? [\n        plugs\n    ] : plugs || [];\n    let options = {\n        skipParse: false\n    };\n    return {\n        process (input, opts) {\n            options = opts || {};\n            const parseFn = options.parser || parse;\n            const renderFn = options.render;\n            const data = options.data || null;\n            if (typeof parseFn !== 'function') {\n                throw new Error('\"parser\" is not a function, please pass to \"process(input, { parser })\" right function');\n            }\n            let tree = options.skipParse ? input || [] : parseFn(input, options);\n            // raw tree before modification with plugins\n            const raw = tree;\n            tree.messages = [];\n            tree.options = options;\n            tree.walk = walk;\n            tree.match = match;\n            plugins.forEach((plugin)=>{\n                tree = plugin(tree, {\n                    parse: parseFn,\n                    render: renderFn,\n                    iterate,\n                    match,\n                    data\n                }) || tree;\n            });\n            return {\n                get html () {\n                    if (typeof renderFn !== 'function') {\n                        throw new Error('\"render\" function not defined, please pass to \"process(input, { render })\"');\n                    }\n                    return renderFn(tree, tree.options);\n                },\n                tree,\n                raw,\n                messages: tree.messages\n            };\n        }\n    };\n}\n","import core from '@bbob/core';\nimport { attrsToString } from '@bbob/plugin-helper';\nconst SELFCLOSE_END_TAG = '/>';\nconst CLOSE_START_TAG = '</';\nconst START_TAG = '<';\nconst END_TAG = '>';\nconst renderNode = (node, { stripTags =false  })=>{\n    if (!node) return '';\n    const type = typeof node;\n    if (type === 'string' || type === 'number') {\n        return node;\n    }\n    if (type === 'object') {\n        if (stripTags === true) {\n            // eslint-disable-next-line no-use-before-define\n            return renderNodes(node.content, {\n                stripTags\n            });\n        }\n        if (node.content === null) {\n            return [\n                START_TAG,\n                node.tag,\n                attrsToString(node.attrs),\n                SELFCLOSE_END_TAG\n            ].join('');\n        }\n        // eslint-disable-next-line no-use-before-define\n        return [\n            START_TAG,\n            node.tag,\n            attrsToString(node.attrs),\n            END_TAG,\n            renderNodes(node.content),\n            CLOSE_START_TAG,\n            node.tag,\n            END_TAG\n        ].join('');\n    }\n    if (Array.isArray(node)) {\n        // eslint-disable-next-line no-use-before-define\n        return renderNodes(node, {\n            stripTags\n        });\n    }\n    return '';\n};\nconst renderNodes = (nodes, { stripTags =false  } = {})=>[].concat(nodes).reduce((r, node)=>r + renderNode(node, {\n            stripTags\n        }), '');\nconst toHTML = (source, plugins, options)=>core(plugins).process(source, {\n        ...options,\n        render: renderNodes\n    }).html;\nexport const render = renderNodes;\nexport default toHTML;\n","/**\n * Plugin that converts consecutive normal spaces (U+0020) to non-breaking spaces (U+00A0).\n * To use, put as function similar to the presets.\n *\n *\n * @example\n * ```ts\n * const output = bbob([preset(), , preserveWhitespace(), lineBreakPlugin()]).process(input, {render}).html\n * ```\n */\nimport { isStringNode } from \"@bbob/plugin-helper\";\n\n/**\n * Checks if input is an object\n * @param value input\n * @returns if value is an object\n */\nconst isObj = (value) => typeof value === \"object\";\n\n/**\n * Walks the tree of nodes. Checks for node of consecutive spaces. If found replaces every space in\n * node with a nonbreaking space.\n * Preserves multiple spaces so html won't truncate them.\n *\n * Walks through entire tree.\n * @param t tree of nodes to be processed\n * @returns modified tree\n */\nconst walk = (t) => {\n  const tree = t;\n\n  if (Array.isArray(tree)) {\n    for (let idx = 0; idx < tree.length; idx++) {\n      const child = walk(tree[idx]);\n      if (Array.isArray(child)) {\n        tree.splice(idx, 1, ...child);\n        idx += child.length - 1;\n      } else {\n        tree[idx] = child;\n      }\n    }\n  } else if (tree && isObj(tree) && tree.content) {\n    walk(tree.content);\n  }\n\n  //Bbob breaks up nodes by the presence of normal spaces.\n  //So a node with a normal space can only have normal spaces in that node.\n  if (isStringNode(tree)) {\n    if (tree.length > 1 && tree[0] === \" \") {\n      let numSpaces = tree.length;\n      return [String.fromCharCode(160).repeat(numSpaces)];\n    }\n  }\n\n  return tree;\n};\n\n/**\n * Converts consecutive normal spaces (U+0020) to nonbreaking spaces (U+00A0).\n * Supply this as a plugin in the preset lists.\n *\n * @example converts consecutive normal spaces (U+0020) to nonbreaking spaces (U+00A0)\n * ```ts\n * const output = bbob([preset(), preserveWhitespace(), lineBreakPlugin()]).process(input, {render}).html\n * ```\n *\n * @returns plugin to be used in BBob process\n */\nexport const preserveWhitespace = () => {\n  return (tree) => walk(tree);\n};\n","import { MD_NEWLINE_INJECT, MD_NEWLINE_INJECT_COMMENT, MD_NEWLINE_PRE_INJECT } from \"./common\";\n\n/**\n * Post Processing designed to fix issues with Markdown and BBCode that the parser can't fix.\n *\n * Separate from markdown-it post processing as it'll be able to manipulate the full string.\n * @param {string} raw string from processing through both BBCode and Markdown\n * @returns post processed string\n */\nfunction removeNewlineInjects(raw) {\n  const processed = raw\n    .replaceAll(MD_NEWLINE_INJECT, \"\")\n    .replaceAll(MD_NEWLINE_PRE_INJECT, \"\")\n    .replaceAll(\"\\n\" + MD_NEWLINE_INJECT_COMMENT, \"\")\n    .replaceAll(MD_NEWLINE_INJECT_COMMENT + \"\\n\", \"\")\n    .replaceAll(MD_NEWLINE_INJECT_COMMENT, \"\"); // Remove all instances of the injected newline\n  return processed;\n}\n\n/**\n * Injects hoisted code blocks back into the raw string\n * @param {string} raw input to inject hoisted code blocks into\n * @param {any} data contains hoist map\n * @returns string with hoisted code blocks injected\n */\nfunction renderHoistedCodeBlocks(raw, data) {\n  const hoistMap = data.hoistMap;\n  for (const [uuid, content] of Object.entries(hoistMap)) {\n    raw = raw.replaceAll(uuid, content);\n  }\n  return raw;\n}\n\n/**\n * Setups the class style tag template for the post\n * @param {string} raw\n * @param {{styles: string[]}} data - contains styles array\n * @returns string\n */\nfunction createClassStyleTagTemplate(raw, data) {\n  if (data.styles.length === 0) {\n    return raw;\n  }\n  const template = '<template data-bbcode-plus=\"class\">' + data.styles.join(\"\\n\") + \"</template>\";\n  return template + raw;\n}\n\n/**\n * Setups the script tag template for the post\n * @param {string} raw\n * @param {{\n *  bbscripts: {\n *    id: string,\n *    class: string,\n *    on: string,\n *    version: string,\n *    content: string\n *  }[]}} data - contains scripts array\n * @returns string\n */\nfunction createScriptTagTemplate(raw, data) {\n  if (data.bbscripts.length === 0) {\n    return raw;\n  }\n  const templates = data.bbscripts.map(\n    (s) =>\n      `<template data-bbcode-plus=\"script\" data-bbscript-id=\"${s.id}\" data-bbscript-class=\"${s.class}\" data-bbscript-on=\"${s.on}\" data-bbscript-ver=\"${s.version}\">${s.content}</template>`,\n  );\n  return templates.join(\"\") + raw;\n}\n\n/**\n * Performs post processing on the raw string to address any necessary functionality that BBob/MD can't handle with a plugin (i.e. hoisting).\n * @param {string} raw processed input from after bbob and md\n * @param {any} data from bbob data\n * @returns final processed string\n */\nexport function postprocess(raw, data) {\n  let final = raw;\n  const postprocessors = [\n    removeNewlineInjects,\n    createClassStyleTagTemplate,\n    createScriptTagTemplate,\n    renderHoistedCodeBlocks,\n  ];\n  for (const postprocessor of postprocessors) {\n    final = postprocessor(final, data);\n  }\n  return final;\n}\n","/**\n * Plugin that converts line breaks to `<br/>` tags.\n * To use, put as function similar to the presets.\n *\n * If a node is marked with `noLineBreakConversion`, then it'll skip the parsing the children\n *\n * @example\n * ```ts\n * const output = bbob([preset(), lineBreakPlugin()]).process(input, {render}).html\n * ```\n */\nimport { isEOL } from \"@bbob/plugin-helper\";\nimport { MD_NEWLINE_INJECT, MD_NEWLINE_PRE_INJECT, URL_REGEX_SINGLE_LINE } from \"../utils/common\";\n\nconst isObj = (value) => typeof value === \"object\";\nconst isString = (value) => typeof value === \"string\";\n\n/**\n * Walks the tree of nodes. Will add `br` tag to all `\\n` in format that can be used in any renderer.\n * Preserves \\n so that markdown-it doesn't try to treat everything like a block\n *\n * If a node has the property noLineBreakConversion is encountered, will skip parsing children.\n * @param t tree of nodes to be processed\n * @returns modified tree\n */\nconst walk = (t, disableLineBreakConversion = false) => {\n  const tree = t;\n\n  if (Array.isArray(tree)) {\n    if (tree.some(isString)) {\n      // array contains strings. Might be md compatible\n      tree.unshift(MD_NEWLINE_INJECT);\n      tree.push(MD_NEWLINE_INJECT);\n    }\n    for (let idx = 0; idx < tree.length; idx++) {\n      const child = walk(tree[idx], disableLineBreakConversion);\n      if (Array.isArray(child)) {\n        tree.splice(idx, 1, ...child);\n        idx += child.length - 1;\n      } else {\n        tree[idx] = child;\n      }\n    }\n  } else if (tree && isObj(tree) && tree.content) {\n    if (tree.isWhitespaceSensitive) {\n      // applies only to [code] and [icode]\n      // stop walk. children won't be parsed to have <br>\n      return tree.tag ? tree : tree.content;\n    }\n    if (tree.disableLineBreakConversion) {\n      disableLineBreakConversion = true;\n    }\n    walk(tree.content, disableLineBreakConversion);\n    return tree.tag ? tree : tree.content;\n  } else if (isString(tree) && URL_REGEX_SINGLE_LINE.test(tree.trim())) {\n    // if the entire string is a URL, then it should be prepared for onebox.\n    // BBob separates strings by newlines anyway, so we can already assume this is sitting on its own line\n    // MD_NEWLINE_INJECT is already replacing newline came before or the start of the array,\n    // so we only need to make sure \\n\\n is added after the URL\n    return [tree, MD_NEWLINE_PRE_INJECT];\n  }\n\n  if (isString(tree) && isEOL(tree)) {\n    return disableLineBreakConversion\n      ? [\"\\n\", MD_NEWLINE_INJECT]\n      : [{ tag: \"br\", content: null }, MD_NEWLINE_INJECT];\n  }\n\n  return tree;\n};\n\n/**\n * Converts `\\n` to `<br/>` self closing tag. Supply this as the last plugin in the preset lists\n *\n * @example converts all line breaks to br\n * ```ts\n * const output = bbob([preset(), lineBreakPlugin()]).process(input, {render}).html\n * ```\n * @example will not convert line breaks inside [nobr]\n * ```ts\n * const nobr = (node: TagNode) => {return { disableLineBreakConversion: true, content: node.content }}; \\\\ tag in preset\n * ...\n * const output = bbob([preset(), lineBreakPlugin()]).process(input, {render}).html\n * ```\n * @returns plugin to be used in BBob process\n */\nexport const lineBreakPlugin = () => {\n  return (tree) => walk(tree);\n};\n","import { ESCAPABLES_REGEX, MD_TABLE_REGEX, generateGUID, regexIndexOf } from \"./common\";\n\n/**\n * Find all code blocks and hoist them out of the content and into a map for later insertion\n * @param {string} raw input to preprocess\n * @returns processed string and hoist map\n */\nfunction fenceCodeBlockPreprocess(content, data) {\n  /** @type {Object.<string, string>} */\n  const hoistMap = {};\n  let index = 0;\n\n  const addHoistAndReturnNewStartPoint = (cutOffStart, cutOffEnd, expected, trim = false) => {\n    const uuid = generateGUID();\n    if (cutOffEnd !== -1) {\n      hoistMap[uuid] = content.substring(cutOffStart, cutOffEnd);\n      content = content.substring(0, cutOffStart) + uuid + content.substring(cutOffEnd);\n    } else {\n      hoistMap[uuid] = content.substring(cutOffStart);\n      content = content.substring(0, cutOffStart) + uuid + expected;\n    }\n    if (trim) {\n      if (hoistMap[uuid].startsWith(\"\\n\")) {\n        hoistMap[uuid] = hoistMap[uuid].substring(1);\n      }\n      if (hoistMap[uuid].endsWith(\"\\n\")) {\n        hoistMap[uuid] = hoistMap[uuid].substring(0, hoistMap[uuid].length - 1);\n      }\n    }\n    return cutOffStart + uuid.length + expected.length;\n  };\n\n  while ((index = regexIndexOf(content, ESCAPABLES_REGEX, index)) !== -1) {\n    const match = ESCAPABLES_REGEX.exec(content.substring(index));\n    if (match.groups?.fence) {\n      const fence = match.groups.fence;\n      const fenceInfo = match.groups.fenceInfo;\n      if (content[index] === \"\\n\") {\n        // Check if the fence is not at the start of the content\n        index += 1;\n      }\n      const closingFenceRegex = new RegExp(\"\\n\" + fence + \"(\\n|$)\"); // Find the next fence. By commonmark spec, it should be the same fence length and type\n      const nextIndex = regexIndexOf(content, closingFenceRegex, index + fence.length);\n\n      const uuid = generateGUID();\n      if (nextIndex !== -1) {\n        hoistMap[uuid] = content.substring(index + fence.length + fenceInfo.length, nextIndex);\n      } else {\n        hoistMap[uuid] = content.substring(index + fence.length + fenceInfo.length);\n      }\n      // inject bbcode tag before and after the code block. This is to prevent BBob plugin from injecting newlines\n      const replacement = `[saveNL]\\n${fence}${fenceInfo}${uuid}\\n${fence}\\n[/saveNL]`;\n      content =\n        content.substring(0, index) +\n        replacement +\n        (nextIndex !== -1 ? content.substring(nextIndex + 1 + fence.length) : \"\");\n      index = index + replacement.length;\n    } else if (match.groups?.bbcode) {\n      const bbcode = match.groups.bbcode;\n      const bbcodeTag = match.groups.bbcodeTag.toLowerCase(); // coerce to lowercase for caseinsensitive matching\n      const closingTag = `[/${bbcodeTag}]`;\n      const nextIndex = content.toLowerCase().indexOf(closingTag, index + 1);\n      index = addHoistAndReturnNewStartPoint(index + bbcode.length, nextIndex, closingTag, true);\n    } else if (match.groups.backtick) {\n      const backtick = match.groups.backtick; // contains whole content\n      const tickStart = match.groups.tickStart;\n      const tickEnd = match.groups.tickEnd;\n      index = addHoistAndReturnNewStartPoint(\n        index + tickStart.length,\n        index + backtick.length - tickEnd.length,\n        tickEnd,\n      );\n    }\n  }\n\n  data.hoistMap = hoistMap;\n  return [content, data];\n}\n\n/**\n * Find all markdown table blocks and mark them to ignore newlines\n * @param {string} raw input to preprocess\n * @returns processed string\n */\nfunction mdTableBlockPreprocess(content, data) {\n  let index = 0;\n  while ((index = regexIndexOf(content, MD_TABLE_REGEX, index)) !== -1) {\n    const match = MD_TABLE_REGEX.exec(content.substring(index));\n    const table = match[0];\n    const replacement = `[saveNL]\\n${table}\\n[/saveNL]`;\n    content = content.substring(0, index) + replacement + content.substring(index + table.length);\n    index = index + replacement.length;\n  }\n  return [content, data];\n}\n\n/**\n * Preprocesses input to be formatted for bbob to intake. Handles any necessary functionality that BBob can't handle with a plugin (i.e. hoisting).\n * @param {string} raw input to preprocess\n * @returns formatted input for bbob to intake\n */\nexport function preprocessRaw(raw) {\n  let data = {};\n  const preprocessors = [fenceCodeBlockPreprocess, mdTableBlockPreprocess];\n  for (const preprocessor of preprocessors) {\n    [raw, data] = preprocessor(raw, data);\n  }\n  return [raw, data];\n}\n","import { availableTags, preset, preventParsing } from \"./preset\";\nimport bbob from \"@bbob/core\";\nimport { render } from \"@bbob/html\";\nimport { preserveWhitespace } from \"./plugins/preserveWhitespace\";\nimport { postprocess } from \"./utils/postprocess\";\nimport { lineBreakPlugin } from \"./plugins/lineBreak\";\nimport { preprocessRaw } from \"./utils/preprocess\";\n\nconst options = {\n  onlyAllowTags: [...availableTags],\n  contextFreeTags: preventParsing, // prevent parsing of children\n  enableEscapeTags: true,\n  onError: (err) => {\n    if (options.previewing) {\n      // eslint-disable-next-line no-console\n      console.warn(err.message, err.lineNumber, err.columnNumber);\n    }\n  },\n};\nconst presetTags = preset();\n\nexport const RpNBBCode = (code, opts) => {\n  const plugins = [presetTags];\n  if (opts.preserveWhitespace) {\n    plugins.push(preserveWhitespace());\n  }\n  plugins.push(lineBreakPlugin());\n  const [preprocessed, preprocessedData] = preprocessRaw(code);\n  return bbob(plugins).process(preprocessed, {\n    render,\n    ...options,\n    data: {\n      ...preprocessedData,\n      previewing: opts.previewing,\n      fonts: new Set(),\n      styles: [],\n      bbscripts: [],\n    },\n  });\n};\n\nexport { postprocess };\n"],"names":["isTagNode","el","tag","process","tags","tree","core","options","walk","node","toNode","attrs","content","preprocessAttr","keys","Object","join","vals","values","_default","toOriginalStartTag","toTagStart","regexIndexOf","string","regex","startpos","indexOf","substring","search","MD_NEWLINE_INJECT","MD_NEWLINE_PRE_INJECT","MD_NEWLINE_INJECT_COMMENT","URL_REGEX_SINGLE_LINE","RegExp","source","ESCAPABLES_REGEX","MD_TABLE_REGEX","generateGUID","d","Date","getTime","window","performance","now","replace","c","r","Math","random","floor","toString","alignment","left","class","center","right","anchor","a","id","trim","name","goto","href","WEB_FONTS","VALID_FONT_STYLES","thin","extralight","light","regular","medium","semibold","bold","extrabold","black","REGISTERED_AXIS","AXES_REGEX","emailHeader","emailFooter","ACCEPTED_OPTIONS","textmessage","attr","message","option","toLowerCase","includes","N","TAB","EQ","QUOTEMARK","SPACE","OPEN_BRAKET","CLOSE_BRAKET","SLASH","BACKSLASH","isStringNode","keysReduce","obj","reduce","def","getNodeLength","count","contentNode","length","escapeHTML","value","attrValue","type","types","boolean","number","object","JSON","stringify","attrsToString","arr","key","getTagAttrs","params","uniqAattr","res","tagAttr","TagNode","this","append","push","appendToNode","openTag","closeTag","toTagEnd","toTagNode","isEmpty","tagStart","constructor","Array","isArray","create","isOf","SLIDE_TITLE_OPEN","Symbol","SLIDE_TITLE_CLOSE","SLIDE_CLOSE","SLIDE_REGEX","markerToString","marker","accordionTags","accordion","groupId","markedContent","contentArr","newArr","shift","foundIndex","match","preContent","slice","postContent","groups","slideTitleOpen","slideTitleClose","slideClose","generateSlideMarkersFromContent","generatedSlides","nodes","currentSlide","prevMarker","customTitle","generateSlidesFromMarkers","filteredContent","filter","n","map","isValid","customSettings","split","s","bright","bcenter","bleft","fleft","fright","some","endsWith","width","find","classes","style","slide","title","isOpen","open","titleAlign","possibleOptions","t","EVENTS","animation","data","previewing","commonGUID","commonId","keyframes","ident","cleanContent","replaceAll","formatted","styles","bg","color","block","defaultOp","blockAttr","blockquote","author","border","val","br","centerblock","percentageInput","check","nameAttr","classSuffix","className","selector","mediaQuery","state","minWidth","maxWidth","unshift","code","isWhitespaceSensitive","inputColor","comment","div","classAttrs","classNames","divide","fieldset","font","fontFamily","family","axes","ital","wght","matches","exec","italic","weight","named_weight","fromEntries","entries","axesParser","url","sort","googleFontApiBuild","fonts","add","custom","fontVar","h","h1","h2","h3","h4","h5","h6","heightrestrict","heightInput","heightValue","parsedHeight","parseHeight","highlight","icode","imagefloat","inlinespoiler","justify","keyframe","mail","attributes","mailAttr","mailOption","person","subject","newspaper","nobr","disableLineBreakConversion","note","ooc","pindent","plain","print","printAttr","printOption","progress","percentageInt","thinprogress","savenl","sh","script","onEvent","on","scriptSetup","version","bbscripts","scroll","side","size","fontSize","fontValue","valid","parsedSize","sizeRanges","unit","parseFontSize","outputAttr","spoiler","providedTitle","sub","sup","tab","tabId","checked","for","tabs","tabsList","forEach","tabNode","b","i","u","availableTags","preset","createPreset","defTags","processor","presetFactory","opts","assign","presetExecutor","extend","callback","TOKEN_TYPE_ID","TOKEN_VALUE_ID","TOKEN_LINE_ID","getTokenValue","token","isTagEnd","charCodeAt","Token","isNaN","isText","isTag","isAttrName","isAttrValue","isStart","isEnd","getName","getTagName","getValue","getLine","getColumn","text","convertTagToText","line","row","Number","String","CharGrabber","cursor","pos","len","hasNext","skip","num","silent","onSkip","curr","getCurr","getRest","getNext","nextPos","getPrev","prevPos","isLast","grabWhile","cond","start","grabN","substrUntilChar","char","idx","createCharGrabber","NodeList","toArray","getLast","flushLast","pop","createList","createLexer","buffer","STATE_WORD","STATE_TAG","STATE_TAG_ATTRS","TAG_STATE_NAME","TAG_STATE_ATTR","TAG_STATE_VALUE","col","tokenIndex","stateMode","tagMode","contextFreeTag","tokens","escapeTags","enableEscapeTags","contextFreeTags","onToken","RESERVED_CHARS","NOT_CHAR_TOKENS","WHITESPACES","SPECIAL_CHARS","isCharReserved","isNewLine","isWhiteSpace","isCharToken","isSpecialChar","isEscapableChar","isEscapeChar","unq","str","charToRemove","charAt","trimChar","checkContextFreeMode","isClosingTag","chars","emitToken","cl","createToken","nextTagState","tagChars","isSingleValueTag","validAttrName","isValue","stateSpecial","validAttrValue","isQM","prevChar","nextChar","isPrevSLASH","isNextEQ","isWS","isNextWS","name1","name2","stateTag","currChar","substr","hasInvalidChars","isNoAttrsInTag","stateAttrs","tagStr","tagGrabber","hasSpace","stateWord","fullTagLen","fullTagName","isChar","tokenize","isTokenNested","parse","input","onlyAllowTags","Boolean","tokenizer","nestedNodes","tagNodes","tagNodesAttrName","nestedTagsMap","Set","isTagNested","tagName","has","flushTagNodes","getNodes","lastNestedNode","appendNodeAsString","isNested","items","item","appendNodes","handleTagStart","tagNode","handleTag","onError","column","lineNumber","columnNumber","handleTagEnd","createTokenizer","lastTagNode","tokenValue","attrName","handleNode","isObj","isBool","iterate","cb","same","expected","actual","every","exp","call","act","ao","eo","expression","SELFCLOSE_END_TAG","CLOSE_START_TAG","START_TAG","END_TAG","renderNodes","stripTags","concat","renderNode","render","child","splice","numSpaces","fromCharCode","repeat","removeNewlineInjects","raw","renderHoistedCodeBlocks","hoistMap","uuid","createClassStyleTagTemplate","createScriptTagTemplate","isString","test","fenceCodeBlockPreprocess","index","addHoistAndReturnNewStartPoint","cutOffStart","cutOffEnd","startsWith","fence","fenceInfo","closingFenceRegex","nextIndex","replacement","bbcode","closingTag","bbcodeTag","backtick","tickStart","tickEnd","mdTableBlockPreprocess","table","err","console","warn","presetTags","plugins","preserveWhitespace","preprocessed","preprocessedData","preprocessors","preprocessor","preprocessRaw","plugs","skipParse","parseFn","parser","renderFn","Error","messages","plugin","html","bbob","final","postprocessors","postprocessor"],"mappings":"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","x_google_ignoreList":[0,9,10,11,49,50,51,52,53,54,55]}