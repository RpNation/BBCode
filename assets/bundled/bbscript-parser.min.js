(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.bbscriptParser = {}));
})(this, (function (exports) { 'use strict';

  /** @typedef {import('./processor').bbscriptOptions} bbscriptOptions */

  /**
   * @typedef {Object.<string, bbscriptFunc>} bbscriptFuncMap
   */
  /**
   * @typedef {Object} bbscriptFunc
   * @property {{types: bbscriptParamTypes[], default?: (number|string|null)}} params
   * @property {bbscriptFunctionCallback} func
   */
  /**
   * @callback bbscriptFunctionCallback
   * @param {bbscriptOptions} options
   * @param {...any} args
   * @returns {(void | string | boolean | number | Promise<void> | bbscriptStop)}
   */
  /**
   * @typedef {Object} bbscriptStop
   * @property {'stop'} msg
   */

  const bbscriptParamTypes = Object.freeze({
    Function: Symbol("Function"),
    String: Symbol("String"),
    Identifier: Symbol("Identifier"),
    Int: Symbol("Int"),
  });

  /**
   * @param {unknown} input
   * @returns {asserts input is bbscriptStop}
   */
  const isStop = (input) => {
    return (
      typeof input === "object" &&
      Object.getOwnPropertyNames(input).includes("msg") &&
      input.msg === "stop"
    );
  };

  /**
   * @typedef {Object} astNode
   * @property {string} name
   * @property {(astNode|string|number)[]} params
   */

  /**
   * @param {unknown} input
   * @returns {asserts input is astNode}
   */
  const isAstNode = (input) => {
    return (
      typeof input === "object" &&
      Object.getOwnPropertyNames(input).every((v) => ["name", "params"].includes(v))
    );
  };
  /**
   * Process input string to produce either a string or the associated data if it is a variable
   * @param {string | number} str input string. Either a string or an identifier
   * @param {bbscriptOptions} options
   * @returns {string} string value
   */
  const getStringVal = (str, options) => {
    if (typeof str === "string" && str.match(/^_(.*)_$/)) {
      if (
        options.callerId &&
        options.data[options.callerId] &&
        options.data[options.callerId][str] !== undefined
      ) {
        // is identifier
        return options.data[options.callerId][str];
      } else {
        return str.match(/^_(.*)_$/)?.[1] || str;
      }
    }
    return str;
  };

  /* eslint-disable no-console */
  class ConsoleLogger {
    static log = console.log;
    static warn = console.warn;
    static error = console.error;
    static info = console.info;
    static debug = console.debug;
  }

  /** @typedef {import('./utils').astNode} astNode */
  /** @typedef {import('./utils').bbscriptFuncMap} bbscriptFuncMap */

  /**
   * @typedef {Object} bbscriptOptions
   * @property {string} callerId
   * @property {string} callerClass
   * @property {any} data
   * @property {BBScriptProcessor} processor
   * @property {Element} target
   */

  let BBScriptProcessor$1 = class BBScriptProcessor {
    /** @type {bbscriptOptions} */
    options;
    /** @type {bbscriptFuncMap} */
    functions;
    /**
     * @param {bbscriptFuncMap} bbscriptFunc
     * @param {bbscriptOptions} [defaultOptions={} as bbscriptOptions]
     */
    constructor(bbscriptFunc, defaultOptions = {}) {
      defaultOptions = {
        ...defaultOptions,
        processor: this,
      };
      this.options = defaultOptions;
      this.functions = bbscriptFunc;
    }
    /**
     * Processes and executes all commands in node tree
     * @param {astNode[]} nodeTree input node tree, generated by `parse()`
     * @param {string} callerId
     * @param {string} callerClass
     * @param {bbscriptOptions} [options=this.options] options to use
     * @returns {Promise<void>}
     */
    async execAll(nodeTree, callerId, callerClass, options = this.options) {
      options = {
        ...this.options,
        ...options,
        callerId,
        callerClass,
      };
      for (const node of nodeTree) {
        const res = await this.exec(node, options);
        if (isStop(res)) {
          return;
        }
      }
    }
    /**
     * Processes and executes a single node
     * @param {astNode} node node to process and execute
     * @param {bbscriptOptions} options bbscript options
     * @returns {(void|string|boolean|number|Promise<void>|import('./utils').bbscriptStop)} returns value if applicable
     */
    exec(node, options) {
      const functions = options.processor.functions;
      const callable = functions[node.name].func;
      if (callable) {
        const args = node.params;
        try {
          return callable(options, ...args);
        } catch (error) {
          ConsoleLogger.warn("BBScript Error", error, node.name, options);
        }
      } else {
        ConsoleLogger.info("invalid command", node.name, options);
      }
    }
    /**
     * Process raw string into AST
     * @param {string} raw input script
     * @returns {astNode[]}
     */
    parse(raw) {
      const nodeTree = [];
      for (let line of raw.split("\n")) {
        line = line.trim();
        if (!line || line.startsWith("//")) {
          continue;
        }
        try {
          nodeTree.push(this.process(this.functions, line)[0]);
        } catch (e) {
          ConsoleLogger.warn(e);
        }
      }
      return nodeTree;
    }
    /**
     * Processes input line into AST node
     * @private
     * @param {bbscriptFuncMap} functions valid bbscript functions
     * @param {string} input input string to process
     * @param {number} [idx=0] optional index of string to start from
     * @returns {[astNode, number]} parsed AST Node and last index
     */
    process(functions, input, idx = 0) {
      const [part1, ...parts] = input.split(/\s+/);
      const name = part1.toLowerCase();
      const params = parts.join(" ");
      const node = {
        name,
        params: [],
      };
      if (!(name in functions)) {
        throw new Error(`Invalid bbscript function name '${name}'`);
      }
      const foundFunc = functions[name];
      // required params
      for (const { types: validParamType, default: defaultValue } of foundFunc.params) {
        let value;
        if (idx >= params.length) {
          if (defaultValue) {
            value = defaultValue;
          } else if (defaultValue == null) {
            // optional param with function defined default
            continue;
          } else {
            ConsoleLogger.warn(`Missing Parameter for ${name}`, validParamType);
            continue;
          }
        }
        let isString = false;
        if (params[idx] === '"') {
          // process quoted string
          [value, idx] = this.getEnclosedParameter(params, idx);
          isString = true;
        } else if (params[idx] === "'") {
          // process quoted string
          [value, idx] = this.getEnclosedParameter(params, idx, "'");
          isString = true;
        } else if (validParamType.includes(bbscriptParamTypes.Function) && params[idx] === "(") {
          // process nested function
          try {
            const [childFunc, overallIdx] = this.getEnclosedParameter(params, idx, ")");
            [value] = this.process(functions, childFunc);
            idx = overallIdx;
          } catch (e) {
            ConsoleLogger.warn(e);
          }
        } else if (validParamType.includes(bbscriptParamTypes.Identifier) && params[idx] === "$") {
          let braceVar = false;
          try {
            braceVar = params[idx + 1] === "{";
          } catch {
            ConsoleLogger.warn(`$ found but no opening {`);
          }
          if (braceVar) {
            [value, idx] = this.getEnclosedParameter(params, ++idx, "}");
          }
        } else {
          // no clue what token is
          value = params.substring(idx).split(/\s+/, 2)[0];
          idx += value.length;
        }
        if (
          validParamType.includes(bbscriptParamTypes.Int) &&
          typeof value === "string" &&
          !isNaN(parseFloat(value))
        ) {
          // if numeric, convert it
          value = parseFloat(value);
        } else if (validParamType.includes(bbscriptParamTypes.String) && isString) ; else if (validParamType.includes(bbscriptParamTypes.Identifier)) {
          value = `_${value}_`;
        }
        if (value !== undefined && value !== null) {
          node.params.push(value);
        }
        while (params[idx]?.match(/\s/)) {
          // skip index to next non-space char
          idx++;
        }
      }
      return [node, idx];
    }
    /**
     * Processed an input string for a single block of string
     * @private
     * @param {string} input input string
     * @param {number} idx index to start from
     * @param {string} [close='"'] closing char to stop at
     * @param {boolean} [trimWrap=true] if `true`, will remove opening and closing chars
     * @returns {[string, number]} found parameter and closing index
     */
    getEnclosedParameter(input, idx, close = '"', trimWrap = true) {
      const startIdx = idx;
      const remainder = input.slice(startIdx);
      const length = input.length;
      idx++;
      while (idx < length) {
        const closeIndex = input.indexOf(close, idx);
        if (!closeIndex) {
          idx = length;
          break;
        }
        // escaped close "
        if (input[closeIndex - 1] === "\\") {
          idx = closeIndex + 1;
          continue;
        }
        idx = closeIndex;
        break;
      }
      if (idx >= length && input[idx] !== close) {
        throw new Error('missing closing "');
      }
      const value = remainder.substring(trimWrap ? 1 : 0, idx - startIdx + (trimWrap ? 0 : 1));
      idx++;
      return [value, idx];
    }
  };

  /** @typedef {import('./utils').astNode} astNode */
  /** @typedef {import('./utils').bbscriptFunc} bbscriptFunc */
  /** @typedef {import('./utils').bbscriptFuncMap} bbscriptFuncMap */
  /** @typedef {import('./processor').bbscriptOptions} bbscriptOptions */

  /**
   * Conditional if then else
   * @type {bbscriptFunc}
   */
  const conditional$1 = {
    params: [
      { types: [bbscriptParamTypes.Function] },
      { types: [bbscriptParamTypes.Function] },
      { types: [bbscriptParamTypes.Function], default: null },
    ],
    func: (options, lhs, rhs, elseBlock) => {
      const result = options.processor.exec(lhs, options);
      if (result) {
        return options.processor.exec(rhs, options);
      } else if (elseBlock) {
        return options.processor.exec(elseBlock, options);
      }
    },
  };
  /**
   * force stop
   * @type {bbscriptFunc}
   */
  const stop$1 = {
    params: [],
    func: () => {
      return { msg: "stop" };
    },
  };
  /**
   * Get the Elements wrapped in JQuery for quick JQuery functionality
   * @param {any} el target input string selector
   * @param {bbscriptOptions} options
   * @returns {any}
   */
  const getJQueryEl$1 = (el, options) => {
    if (el) {
      el = "." + getStringVal(el, options).trim() + "__" + options.callerId;
    } else {
      el = $(options.target);
    }
    return $(el);
  };
  const addClass$1 = {
    params: [
      { types: [bbscriptParamTypes.Identifier] },
      { types: [bbscriptParamTypes.Identifier], default: null },
    ],
    func: (options, newClass, target = "") => {
      newClass = getStringVal(newClass, options) || "";
      newClass &&= newClass + "__" + options.callerId;
      getJQueryEl$1(target, options).addClass(newClass);
    },
  };
  const removeClass$1 = {
    params: [
      { types: [bbscriptParamTypes.Identifier] },
      { types: [bbscriptParamTypes.Identifier], default: null },
    ],
    func: (options, oldClass, target = "") => {
      oldClass = getStringVal(oldClass, options) || "";
      oldClass &&= oldClass + "__" + options.callerId;
      getJQueryEl$1(target, options).removeClass(oldClass);
    },
  };
  const fadeIn$1 = {
    params: [
      { types: [bbscriptParamTypes.Int], default: 1000 },
      { types: [bbscriptParamTypes.Identifier], default: null },
    ],
    func: (options, time = 1000, target) => {
      getJQueryEl$1(target, options).fadeIn(time);
    },
  };
  const fadeOut$1 = {
    params: [
      { types: [bbscriptParamTypes.Int], default: 1000 },
      { types: [bbscriptParamTypes.Identifier], default: null },
    ],
    func: (options, time = 1000, target) => {
      getJQueryEl$1(target, options).fadeOut(time);
    },
  };
  const fadeToggle$1 = {
    params: [
      { types: [bbscriptParamTypes.Int], default: 1000 },
      { types: [bbscriptParamTypes.Identifier], default: null },
    ],
    func: (options, time = 1000, target) => {
      getJQueryEl$1(target, options).fadeToggle(time);
    },
  };
  const hide$1 = {
    params: [{ types: [bbscriptParamTypes.Identifier], default: null }],
    func: (options, target) => {
      getJQueryEl$1(target, options).hide();
    },
  };
  const show$1 = {
    params: [{ types: [bbscriptParamTypes.Identifier], default: null }],
    func: (options, target) => {
      getJQueryEl$1(target, options).show();
    },
  };
  const getText$1 = {
    params: [{ types: [bbscriptParamTypes.Identifier], default: null }],
    func: (options, target) => {
      return getJQueryEl$1(target, options).text();
    },
  };
  const setText$1 = {
    params: [
      {
        types: [
          bbscriptParamTypes.String,
          bbscriptParamTypes.Function,
          bbscriptParamTypes.Identifier,
        ],
      },
      { types: [bbscriptParamTypes.Identifier], default: null },
    ],
    func: (options, input, target) => {
      if (isAstNode(input)) {
        input = options.processor.exec(input, options);
      } else {
        input = getStringVal(input, options);
      }
      getJQueryEl$1(target, options).text(input);
    },
  };
  const getVal$1 = {
    params: [{ types: [bbscriptParamTypes.Identifier], default: null }],
    func: (options, target) => {
      return getJQueryEl$1(target, options).val();
    },
  };
  const setVal$1 = {
    params: [
      {
        types: [
          bbscriptParamTypes.String,
          bbscriptParamTypes.Function,
          bbscriptParamTypes.Identifier,
        ],
      },
      { types: [bbscriptParamTypes.Identifier], default: null },
    ],
    func: (options, input, target) => {
      if (isAstNode(input)) {
        input = options.processor.exec(input, options);
      } else {
        input = getStringVal(input, options);
      }
      getJQueryEl$1(target, options).val(input);
    },
  };
  const slideDown$1 = {
    params: [
      { types: [bbscriptParamTypes.Int], default: 1000 },
      { types: [bbscriptParamTypes.Identifier], default: null },
    ],
    func: (options, time = 1000, target) => {
      getJQueryEl$1(target, options).slideDown(time);
    },
  };
  const slideUp$1 = {
    params: [
      { types: [bbscriptParamTypes.Int], default: 1000 },
      { types: [bbscriptParamTypes.Identifier], default: null },
    ],
    func: (options, time = 1000, target) => {
      getJQueryEl$1(target, options).slideUp(time);
    },
  };
  const slideToggle$1 = {
    params: [
      { types: [bbscriptParamTypes.Int], default: 1000 },
      { types: [bbscriptParamTypes.Identifier], default: null },
    ],
    func: (options, time = 1000, target) => {
      getJQueryEl$1(target, options).slideToggle(time);
    },
  };
  const params = [
    {
      types: [
        bbscriptParamTypes.String,
        bbscriptParamTypes.Function,
        bbscriptParamTypes.Int,
        bbscriptParamTypes.Identifier,
      ],
    },
    {
      types: [
        bbscriptParamTypes.String,
        bbscriptParamTypes.Function,
        bbscriptParamTypes.Int,
        bbscriptParamTypes.Identifier,
      ],
    },
  ];
  /**
   * Common evaluate method to process left and right arguments first if they are nested
   * @param {bbscriptOptions} options
   * @param {unknown} lhs
   * @param {unknown} rhs
   * @returns {any[]}
   */
  const evaluate = (options, lhs, rhs) => {
    let leftResult;
    let rightResult;
    if (isAstNode(lhs)) {
      leftResult = options.processor.exec(lhs, options);
    } else {
      leftResult = getStringVal(lhs, options);
    }
    if (isAstNode(rhs)) {
      rightResult = options.processor.exec(rhs, options);
    } else {
      rightResult = getStringVal(rhs, options);
    }
    return [leftResult, rightResult];
  };
  /**
   * is equal to
   * @type {bbscriptFunc}
   */
  const eq = {
    params,
    func: (options, lhs, rhs) => {
      const [leftResult, rightResult] = evaluate(options, lhs, rhs);
      // eslint-disable-next-line eqeqeq
      return leftResult == rightResult;
    },
  };
  /**
   * is greater than
   * @type {bbscriptFunc}
   */
  const ge = {
    params,
    func: (options, lhs, rhs) => {
      const [leftResult, rightResult] = evaluate(options, lhs, rhs);
      return leftResult > rightResult;
    },
  };
  /**
   * is greater than or equal to
   * @type {bbscriptFunc}
   */
  const geq = {
    params,
    func: (options, lhs, rhs) => {
      const [leftResult, rightResult] = evaluate(options, lhs, rhs);
      return leftResult >= rightResult;
    },
  };
  /**
   * is less than
   * @type {bbscriptFunc}
   */
  const le = {
    params,
    func: (options, lhs, rhs) => {
      const [leftResult, rightResult] = evaluate(options, lhs, rhs);
      return leftResult < rightResult;
    },
  };
  /**
   * is less than or equal to
   * @type {bbscriptFunc}
   */
  const leq = {
    params,
    func: (options, lhs, rhs) => {
      const [leftResult, rightResult] = evaluate(options, lhs, rhs);
      return leftResult >= rightResult;
    },
  };
  const random$1 = {
    params: [{ types: [bbscriptParamTypes.Int] }, { types: [bbscriptParamTypes.Int] }],
    func: (options, min, max) => {
      return Math.floor(Math.random() * (max - min + 1) + min);
    },
  };
  const print$1 = {
    params: [{ types: [bbscriptParamTypes.String, bbscriptParamTypes.Identifier] }],
    func: (options, args) => {
      ConsoleLogger.log(getStringVal(args, options));
    },
  };
  /**
   * Set variable
   * @type {bbscriptFunc}
   */
  const set = {
    params: [
      { types: [bbscriptParamTypes.Identifier] },
      { types: [bbscriptParamTypes.Int, bbscriptParamTypes.String, bbscriptParamTypes.Function] },
    ],
    func: (options, id, value) => {
      if (isAstNode(value)) {
        value = options.processor.exec(value, options);
      } else {
        value = getStringVal(value, options);
      }
      const callerId = options.callerId || "";
      if (!(callerId in options.data)) {
        options.data[callerId] = {};
      }
      options.data[callerId][id] = value;
    },
  };
  const add$1 = {
    params: [
      {
        types: [
          bbscriptParamTypes.Int,
          bbscriptParamTypes.String,
          bbscriptParamTypes.Identifier,
          bbscriptParamTypes.Function,
        ],
      },
      {
        types: [
          bbscriptParamTypes.Int,
          bbscriptParamTypes.String,
          bbscriptParamTypes.Identifier,
          bbscriptParamTypes.Function,
        ],
      },
    ],
    func: (options, a, b) => {
      if (isAstNode(a)) {
        a = options.processor.exec(a, options);
      } else {
        a = getStringVal(a, options);
      }
      if (isAstNode(b)) {
        b = options.processor.exec(b, options);
      } else {
        b = getStringVal(b, options);
      }
      return a + b;
    },
  };
  const dec = {
    params: [
      { types: [bbscriptParamTypes.Identifier] },
      { types: [bbscriptParamTypes.Int], default: 1 },
    ],
    func: (options, id, amount = 1) => {
      try {
        options.data[id] -= amount;
      } catch (e) {
        ConsoleLogger.warn(`${id} is not a number`, e);
      }
    },
  };

  const inc = {
    params: [
      { types: [bbscriptParamTypes.Identifier] },
      { types: [bbscriptParamTypes.Int], default: 1 },
    ],
    func: (options, id, amount = 1) => {
      try {
        options.data[id] += amount;
      } catch (e) {
        ConsoleLogger.warn(`${id} is not a number`, e);
      }
    },
  };

  /**
   * Map between bbscript function name and logic.
   * keys must be all lowercase. Parser will apply lowercase to user input,
   * so is case-insensitive.
   * @type {bbscriptFuncMap}
   */
  const bbscriptFunctions$1 = {
    print: print$1,
    eq,
    ge,
    geq,
    le,
    leq,
    if: conditional$1,
    stop: stop$1,
    set,
    dec,
    inc,
    addclass: addClass$1,
    removeclass: removeClass$1,
    fadein: fadeIn$1,
    fadeout: fadeOut$1,
    fadetoggle: fadeToggle$1,
    hide: hide$1,
    show: show$1,
    gettext: getText$1,
    settext: setText$1,
    getval: getVal$1,
    setVal: setVal$1,
    slidedown: slideDown$1,
    slideup: slideUp$1,
    slidetoggle: slideToggle$1,
    random: random$1,
    add: add$1,
  };

  /** @typedef {import('./processor.js').bbscriptOptions} bbscript1Options */
  /**
   * @param {any} bbscriptData
   * @returns {BBScript1Processor}
   */
  function initBBScript1(bbscriptData) {
    return new BBScriptProcessor$1(bbscriptFunctions$1, { data: bbscriptData });
  }

  /** @typedef {import('./processor').BBScriptOptions} BBScriptOptions */
  /** @typedef {import('./utils').BBScriptReturnTypes} BBScriptReturnTypes */

  class ASTNode {
    /** @type {number} */
    _startIdx;
    /** @type {number} */
    _endIdx;

    /**
     * @param {number} startIdx
     * @param {number} endIdx
     */
    constructor(startIdx, endIdx) {
      this._startIdx = startIdx;
      this._endIdx = endIdx;
    }
    /**
     * @public
     * @returns {number}
     */
    get startIdx() {
      return this._startIdx;
    }
    /**
     * @public
     * @returns {number}
     */
    get endIdx() {
      return this._endIdx;
    }
    /**
     * returns information about the text of the node in the original script
     * @public
     * @param {string} text input string
     * @returns {{ line: number; column: number; text: string; }}
     */
    findInText(text) {
      let line = 1;
      let column = 1;
      for (let i = 0; i < text.length; i++) {
        if (i === this.startIdx) {
          break;
        }
        if (text[i] === "\n") {
          line++;
          column = 0;
        }
        column++;
      }
      return {
        line,
        column,
        text: text.substring(this.startIdx, this.endIdx),
      };
    }
  }

  /** @extends ASTNode */
  class ASTIdentifier extends ASTNode {
    /** @type {string} */
    _name;

    /**
     * @param {number} startIdx
     * @param {number} endIdx
     * @param {string} name
     */
    constructor(startIdx, endIdx, name) {
      super(startIdx, endIdx);
      this._name = name;
    }
    /**
     * @public
     * @returns {string}
     */
    get name() {
      return this._name;
    }
    /**
     * @public
     * @param {BBScriptOptions} options
     * @returns {any}
     */
    resolveValue(options) {
      if (
        options.callerId &&
        options.data[options.callerId] &&
        options.data[options.callerId][this.name] !== undefined
      ) {
        return options.data[options.callerId][this.name];
      } else {
        return this.name;
      }
    }
  }

  /** @extends ASTNode */
  class ASTFunction extends ASTNode {
    /** @type {ASTIdentifier} */
    _identifier;
    /** @type {ASTNode[]} */
    _params;

    /**
     * @param {number} startIdx
     * @param {number} endIdx
     * @param {ASTIdentifier} name
     * @param {ASTNode[]} params
     */
    constructor(startIdx, endIdx, name, params) {
      super(startIdx, endIdx);
      this._identifier = name;
      this._params = params;
    }
    /**
     * @public
     * @returns {ASTIdentifier}
     */
    get identifier() {
      return this._identifier;
    }
    /**
     * @public
     * @returns {ASTNode[]}
     */
    get params() {
      return this._params;
    }
    /**
     * Processes and executes a single node
     * @public
     * @param {BBScriptOptions} options bbscript options
     * @returns {BBScriptReturnTypes} returns value if applicable
     */
    resolveValue(options) {
      const functions = options.processor.functions;
      const callable = functions[this.identifier.name];
      if (callable) {
        const args = this.params;
        try {
          return callable(options, ...args);
        } catch (error) {
          ConsoleLogger.warn("BBScript Error", error, this, options);
        }
      }
      ConsoleLogger.info("invalid command", this, options);
    }
  }

  /** @extends ASTNode */
  class ASTQuotedString extends ASTNode {
    /** @type {string} */
    _string;

    /**
     * @param {number} startIdx
     * @param {number} endIdx
     * @param {string} input
     */
    constructor(startIdx, endIdx, input) {
      super(startIdx, endIdx);
      this._string = input;
    }
    /**
     * @public
     * @returns {string}
     */
    get string() {
      return this._string;
    }
    /**
     * @public
     * @returns {string}
     */
    resolveValue() {
      return this.string;
    }
  }

  /** @extends ASTNode */
  class ASTList extends ASTNode {
    /** @type {ASTNode[]} */
    _items;
    /**
     * @param {number} startIdx
     * @param {number} endIdx
     * @param {ASTNode[]} elements
     */
    constructor(startIdx, endIdx, elements) {
      super(startIdx, endIdx);
      this._items = elements;
    }
    /**
     * @public
     * @returns {ASTNode[]}
     */
    get items() {
      return this._items;
    }
    /**
     * @public
     * @param {BBScriptOptions} options
     * @returns {(string | number | boolean)[]}
     */
    resolveValue(options) {
      return this.items.map((i) => i.resolveValue(options));
    }
  }

  /** @extends ASTNode */
  class ASTNumberLiteral extends ASTNode {
    /** @type {string} */
    _value;

    /**
     * @param {number} startIdx
     * @param {number} endIdx
     * @param {string} value
     */
    constructor(startIdx, endIdx, value) {
      super(startIdx, endIdx);
      this._value = value;
    }
    /**
     * @public
     * @returns {string}
     */
    get value() {
      return this._value;
    }
    /**
     * @public
     * @returns {number}
     */
    resolveValue() {
      return +this.value;
    }
  }

  /** @typedef {import('./AST').ASTNode} ASTNode */
  /** @extends Error */
  class ASTError extends Error {
    /** @type {ASTNode | null} */
    node;

    /**
     * @param {ASTNode | null} node
     * @param {string} message
     */
    constructor(node, message) {
      super(message);
      this.name = "ASTError";
      this.node = node;
    }
    /**
     * @public
     * @param {string} text
     * @returns {string}
     */
    format(text) {
      if (this.node !== null) {
        const details = this.node.findInText(text);
        this.message += `: ${details.text} (line ${details.line}, column ${details.column})`;
      }
      return this.message;
    }
  }

  /** @typedef {import('./AST').ASTNode} ASTNode */

  class BBScriptParser {
    /** @type {ASTNode[]} */
    ast = [];
    /** @type {string} */
    text = "";
    /** @type {number} */
    length = 0; // separate value for better dev
    /** @type {ASTError[]} */
    errors = [];
    /** @type {number} */
    pos = 0;

    /**
     * Parse input string into AST tree for later processing
     * @param {string} input string to parse
     * @returns {{ ast: ASTNode[]; formattedErrors: string[]; }} AST Tree to be processed in BBScript 2 syntax
     */
    parse(input) {
      this.text = input;
      this.length = this.text.length;
      let fatalError;
      try {
        this.buildAst();
      } catch (e) {
        fatalError = new ASTError(null, e?.message);
      }
      if (fatalError) {
        this.errors.push(fatalError);
      }
      const formattedErrors = this.errors.map((e) => e.format(this.text));
      return {
        ast: this.ast,
        formattedErrors,
      };
    }
    /**
     * Builds an AST
     * @private
     * @returns {ASTNode[]} AST
     */
    buildAst() {
      this.ast = [];
      this.errors = [];
      this.pos = 0;
      let node;
      while (this.pos < this.length) {
        // consume whitespace
        this.consumeWhitespace();
        if (this.pos >= this.length) {
          break;
        }
        // top-level function
        if (this.head() === "(") {
          node = this.processFunctionCall();
        } else {
          this.errors.push(new ASTError(null, "Expecting function call, found " + this.head()));
          break;
        }
        if (node !== null) {
          this.ast.push(node);
        }
      }
      return this.ast;
    }
    /**
     * Returns the current character at the cursor
     * @private
     * @param {boolean} [throwOnError=true] throw an error if unexpected end of script
     * @returns {string | null} single character string or `null`
     */
    head(throwOnError = true) {
      if (this.pos < this.length) {
        return this.text[this.pos];
      }
      if (throwOnError) {
        throw new Error("Unexpected end of script");
      }
      return null;
    }
    /**
     * Advance the cursor position if the current cursor points to a whitespace
     * @private
     * @returns {void}
     */
    consumeWhitespace() {
      while (this.pos < this.length && this.isWhitespaceChar()) {
        this.pos++;
      }
    }
    /**
     * @private
     * @param {string} [char=this.head() || '']
     * @returns {boolean}
     */
    isWhitespaceChar(char = this.head() || "") {
      return /\s/.test(char);
    }
    /**
     * Processes the following substring at the cursor position as a function call
     * @private
     * @returns {ASTFunction} ASTFunction node
     */
    processFunctionCall() {
      const startIdx = this.pos;
      // consume starting parentheses
      this.pos++;
      const name = this.processIdentifier(")", /[^+\-_*/%<>=!a-zA-Z]/gm);
      this.consumeWhitespace();
      const params = [];
      while (this.head() !== ")") {
        this.consumeWhitespace();
        const char = this.head();
        switch (char) {
          case "(":
            params.push(this.processFunctionCall());
            break;
          case '"':
            params.push(this.processString());
            break;
          case "[":
            params.push(this.processList());
            break;
          case ")":
            // end of function.
            break;
          default:
            if (char === "-" || /\d/.test(char || "")) {
              params.push(this.processNumber());
            } else {
              params.push(this.processIdentifier());
            }
            break;
        }
      }
      // consume ending parentheses
      this.pos++;
      const endIdx = this.pos;
      return new ASTFunction(startIdx, endIdx, name, params);
    }
    /**
     * Processes a double quoted string starting at the cursor position into an ASTNode
     * @private
     * @returns {ASTQuotedString}
     */
    processString() {
      let string = "";
      const startIdx = this.pos;
      this.pos++;
      let escaped = false;
      while (this.head() !== null) {
        const char = this.head();
        if (char === '"') {
          if (!escaped) {
            break;
          }
          string += char;
          escaped = false;
        } else if (char === "\\") {
          if (escaped) {
            string += char;
          }
          escaped = !escaped;
        } else {
          string += char;
          escaped = false;
        }
        this.pos++;
      }
      const endIdx = this.pos;
      this.pos++;
      return new ASTQuotedString(startIdx, endIdx, string.replace("\n", "\\n"));
    }
    /**
     * Processes a bracketed list starting at the cursor position into an ASTNode
     *
     * expects `[item1 item2 item3]`
     * @private
     * @returns {ASTList}
     */
    processList() {
      const startIdx = this.pos;
      this.pos++;
      const items = [];
      while (this.head() !== null) {
        this.consumeWhitespace();
        const char = this.head();
        if (char === "]") {
          break;
        }
        switch (char) {
          case "(":
            items.push(this.processFunctionCall());
            break;
          case '"':
            items.push(this.processString());
            break;
          case "[":
            items.push(this.processList());
            break;
          default:
            if (char === "-" || /\d/.test(char || "")) {
              items.push(this.processNumber("]"));
            } else {
              items.push(this.processIdentifier("]"));
            }
            break;
        }
      }
      // consume closing brace
      this.pos++;
      const endIdx = this.pos;
      return new ASTList(startIdx, endIdx, items);
    }
    /**
     * Processes a number literal starting at the cursor position
     * @private
     * @param {string} [end=')'] terminating characters to stop at
     * @returns {ASTNumberLiteral}
     */
    processNumber(end = ")") {
      const startIdx = this.pos;
      if (this.head() === "-") {
        this.pos++;
      }
      while (!this.isWhitespaceChar() && this.head() !== end) {
        this.pos++;
      }
      const endIdx = this.pos;
      const value = this.text.substring(startIdx, endIdx);
      const numberLiteral = new ASTNumberLiteral(startIdx, endIdx, value);
      if (isNaN(+value)) {
        this.errors.push(new ASTError(numberLiteral, "Invalid number literal"));
      }
      return numberLiteral;
    }
    /**
     * Processes an identifier at the cursor position
     * @private
     * @param {string} [end=')'] end character to stop at
     * @param {RegExp} [invalidChars=/[^_a-zA-Z]/gm] regex to check against
     * @returns {ASTIdentifier}
     */
    processIdentifier(end = ")", invalidChars = /[^_a-zA-Z]/gm) {
      const nameStartIdx = this.pos;
      while (!this.isWhitespaceChar() && this.head() !== end) {
        this.pos++;
      }
      const nameEndIdx = this.pos;
      const identifier = new ASTIdentifier(
        nameStartIdx,
        nameEndIdx,
        this.text.substring(nameStartIdx, nameEndIdx),
      );
      // validate identifier
      if (invalidChars.test(identifier.name)) {
        this.errors.push(new ASTError(identifier, "Invalid function identifier"));
      }
      if (identifier.name.length === 0) {
        this.errors.push(new ASTError(identifier, "Missing function identifier"));
      }
      return identifier;
    }
  }

  /** @typedef {import('./AST').ASTNode} ASTNode */
  /** @typedef {import('./utils').BBScriptFuncMap} BBScriptFuncMap */

  /**
   * @typedef {Object} BBScriptOptions
   * @property {string} callerId
   * @property {string} callerClass
   * @property {any} data
   * @property {BBScriptProcessor} processor
   * @property {Element} target
   */

  class BBScriptProcessor {
    /** @type {BBScriptOptions} */
    options;
    /** @type {BBScriptFuncMap} */
    functions;

    /**
     * @param {BBScriptFuncMap} functions
     * @param {BBScriptOptions} [defaultOptions={} as BBScriptOptions]
     */
    constructor(functions, defaultOptions = {}) {
      defaultOptions = {
        ...defaultOptions,
        processor: this,
      };
      this.options = defaultOptions;
      this.functions = functions;
    }
    /**
     * Processes and executes all commands in node tree
     * @param {ASTNode[]} nodeTree input node tree, generated by `parse()`
     * @param {string} callerId
     * @param {string} callerClass
     * @param {BBScriptOptions} [options=this.options] options to use
     * @returns {void}
     */
    execAll(nodeTree, callerId, callerClass, options = this.options) {
      options = {
        ...this.options,
        ...options,
        callerId,
        callerClass,
      };
      for (const node of nodeTree) {
        node.resolveValue(options);
      }
    }
  }

  /** @typedef {import('./utils').BBScriptFunc} BBScriptFunc */
  /** @typedef {import('./utils').BBScriptFuncMap} BBScriptFuncMap */
  /** @typedef {import('./utils').BBScriptReturnTypes} BBScriptReturnTypes */
  /** @typedef {import('./AST').ASTNode} ASTNode */
  /** @typedef {import('./processor').BBScriptOptions} BBScriptOptions */

  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} arr
   * @returns {number}
   */
  const count = (options, arr) => {
    const arrVal = arr.resolveValue(options);
    if (Array.isArray(arrVal) || typeof arrVal === "string") {
      return arrVal.length;
    } else {
      throw new ASTError(arr, "Does not resolve to an array or string");
    }
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} arr
   * @param {ASTNode} needle
   * @returns {boolean}
   */
  const contain = (options, arr, needle) => {
    const arrVal = arr.resolveValue(options);
    const needleVal = needle.resolveValue(options);
    if (Array.isArray(arrVal) && needleVal !== undefined) {
      return arrVal.includes(needleVal);
    }
    if (typeof arrVal === "string" && needleVal !== undefined) {
      return arrVal.includes(needleVal);
    }
    if (!Array.isArray(arrVal) || typeof arrVal !== "string") {
      throw new ASTError(arr, "Does not resolve to an array or string");
    }
    return false;
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} arr
   * @param {ASTNode} needle
   * @returns {number}
   */
  const find = (options, arr, needle) => {
    const arrVal = arr.resolveValue(options);
    const needleVal = needle.resolveValue(options);
    if (Array.isArray(arrVal) && needleVal !== undefined) {
      return arrVal.indexOf(needleVal);
    }
    if (!Array.isArray(arrVal)) {
      throw new ASTError(arr, "Does not resolve to an array");
    }
    return -1;
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} arr
   * @param {ASTNode} i
   * @param {ASTNode | undefined} [val]
   * @returns {BBScriptReturnTypes}
   */
  const index = (options, arr, i, val) => {
    const arrVal = arr.resolveValue(options);
    const idx = +i.resolveValue(options);
    if (!Array.isArray(arrVal)) {
      throw new ASTError(arr, "Does not resolve to an array");
    }
    if (val === undefined) {
      return arrVal[idx];
    }
    const newVal = val.resolveValue(options);
    arrVal[idx] = newVal;
    return arrVal[idx];
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} arr
   * @param {ASTNode} val
   * @returns {number}
   */
  const append = (options, arr, val) => {
    const arrVal = arr.resolveValue(options);
    const newVal = val.resolveValue(options);
    if (!Array.isArray(arrVal)) {
      throw new ASTError(arr, "Does not resolve to an array");
    }
    // js array is pass by reference, so options.data will be updated if applicable
    return arrVal.push(newVal);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} arr
   * @param {ASTNode} i
   * @param {ASTNode} val
   * @returns {void}
   */
  const insert = (options, arr, i, val) => {
    const arrVal = arr.resolveValue(options);
    if (!Array.isArray(arrVal)) {
      throw new ASTError(arr, "Does not resolve to an array");
    }
    const idx = +i.resolveValue(options);
    if (typeof idx !== "number") {
      throw new ASTError(i, "Does not resolve to a number");
    }
    const newVal = val.resolveValue(options);
    arrVal.splice(Math.floor(idx), 0, newVal);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} arr
   * @returns {BBScriptReturnTypes | undefined}
   */
  const pop = (options, arr) => {
    const arrVal = arr.resolveValue(options);
    if (!Array.isArray(arrVal)) {
      throw new ASTError(arr, "Does not resolve to an array");
    }
    return arrVal.pop();
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} arr
   * @param {ASTNode} i
   * @returns {BBScriptReturnTypes}
   */
  const remove = (options, arr, i) => {
    const arrVal = arr.resolveValue(options);
    if (!Array.isArray(arrVal)) {
      throw new ASTError(arr, "Does not resolve to an array");
    }
    const idx = +i.resolveValue(options);
    return arrVal.splice(idx, 1)[0];
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} arr
   * @returns {BBScriptReturnTypes[]}
   */
  const reverse = (options, arr) => {
    const arrVal = arr.resolveValue(options);
    if (!Array.isArray(arrVal)) {
      throw new ASTError(arr, "Does not resolve to an array");
    }
    return arrVal.reverse();
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} arr
   * @param {ASTNode | undefined} [sep]
   * @returns {string}
   */
  const join = (options, arr, sep) => {
    const arrVal = arr.resolveValue(options);
    let sepVal = "";
    if (!Array.isArray(arrVal)) {
      throw new ASTError(arr, "Does not resolve to an array");
    }
    if (sep !== undefined) {
      sepVal = String(sep.resolveValue(options));
    }
    return arrVal.join(sepVal);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} arr
   * @returns {BBScriptReturnTypes[]}
   */
  const shuffle = (options, arr) => {
    const arrVal = arr.resolveValue(options);
    if (!Array.isArray(arrVal)) {
      throw new ASTError(arr, "Does not resolve to an array");
    }
    for (let i = arrVal.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arrVal[i], arrVal[j]] = [arrVal[j], arrVal[i]];
    }
    return arrVal;
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} arr
   * @param {ASTNode} start
   * @param {ASTNode} end
   * @returns {string | BBScriptReturnTypes[]}
   */
  const slice = (options, arr, start, end) => {
    const val = arr.resolveValue(options);
    if (!Array.isArray(val) && typeof val !== "string") {
      throw new ASTError(arr, "Does not resolve to an array or string");
    }
    const startVal = +start.resolveValue(options);
    const endVal = +end.resolveValue(options);
    return val.slice(startVal, endVal);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} arr
   * @param {ASTNode} func
   * @param {ASTNode | undefined} [token]
   * @returns {void}
   */
  const each = (options, arr, func, token) => {
    const arrVal = arr.resolveValue(options);
    if (!Array.isArray(arrVal)) {
      throw new ASTError(arr, "Does not resolve to an array");
    }
    const tokenVar = token !== undefined ? String(token.resolveValue(options)) : "_";
    // eslint-disable-next-line eqeqeq
    if (options.data[options.callerId] == undefined) {
      options.data[options.callerId] = {};
    }
    for (const e of arrVal) {
      options.data[options.callerId][tokenVar] = e;
      func.resolveValue(options);
    }
    delete options.data[options.callerId][tokenVar];
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode | undefined} [target]
   * @returns {any}
   */
  const getJQueryEl = (options, target) => {
    if (target !== undefined) {
      const search = "." + String(target.resolveValue(options)).trim() + "__" + options.callerId;
      return $(search);
    } else {
      return $(options.target);
    }
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} newClass
   * @param {ASTNode | undefined} [target]
   * @returns {void}
   */
  const addClass = (options, newClass, target) => {
    let className = String(newClass.resolveValue(options));
    className &&= className + "__" + options.callerId;
    const targetEl = getJQueryEl(options, target);
    targetEl.addClass(className);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} oldClass
   * @param {ASTNode | undefined} [target]
   * @returns {void}
   */
  const removeClass = (options, oldClass, target) => {
    let className = String(oldClass.resolveValue(options));
    className &&= className + "__" + options.callerId;
    const targetEl = getJQueryEl(options, target);
    targetEl.removeClass(className);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode | undefined} [duration]
   * @param {ASTNode | undefined} [target]
   * @returns {void}
   */
  const fadeIn = (options, duration, target) => {
    const targetEl = getJQueryEl(options, target);
    if (duration !== undefined) {
      const time = +duration.resolveValue(options);
      targetEl.fadeIn(time || 1000);
    } else {
      targetEl.fadeIn(1000);
    }
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode | undefined} [duration]
   * @param {ASTNode | undefined} [target]
   * @returns {void}
   */
  const fadeOut = (options, duration, target) => {
    const targetEl = getJQueryEl(options, target);
    if (duration !== undefined) {
      const time = +duration.resolveValue(options);
      targetEl.fadeOut(time || 1000);
    } else {
      targetEl.fadeOut(1000);
    }
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode | undefined} [duration]
   * @param {ASTNode | undefined} [target]
   * @returns {void}
   */
  const fadeToggle = (options, duration, target) => {
    const targetEl = getJQueryEl(options, target);
    if (duration !== undefined) {
      const time = +duration.resolveValue(options);
      targetEl.fadeToggle(time || 1000);
    } else {
      targetEl.fadeToggle(1000);
    }
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode | undefined} [target]
   * @returns {void}
   */
  const hide = (options, target) => {
    const targetEl = getJQueryEl(options, target);
    targetEl.hide();
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode | undefined} [target]
   * @returns {void}
   */
  const show = (options, target) => {
    const targetEl = getJQueryEl(options, target);
    targetEl.show();
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode | undefined} [target]
   * @returns {any}
   */
  const getText = (options, target) => {
    const targetEl = getJQueryEl(options, target);
    return targetEl.text();
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} text
   * @param {ASTNode | undefined} [target]
   * @returns {void}
   */
  const setText = (options, text, target) => {
    const targetEl = getJQueryEl(options, target);
    const textVal = text.resolveValue(options);
    targetEl.text(textVal);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode | undefined} [target]
   * @returns {any}
   */
  const getVal = (options, target) => {
    const targetEl = getJQueryEl(options, target);
    return targetEl.val();
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} val
   * @param {ASTNode | undefined} [target]
   * @returns {void}
   */
  const setVal = (options, val, target) => {
    const targetEl = getJQueryEl(options, target);
    const newVal = val.resolveValue(options);
    targetEl.val(newVal);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode | undefined} [duration]
   * @param {ASTNode | undefined} [target]
   * @returns {void}
   */
  const slideDown = (options, duration, target) => {
    const targetEl = getJQueryEl(options, target);
    if (duration !== undefined) {
      const time = +duration.resolveValue(options);
      targetEl.slideDown(time || 1000);
    } else {
      targetEl.slideDown(1000);
    }
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode | undefined} [duration]
   * @param {ASTNode | undefined} [target]
   * @returns {void}
   */
  const slideUp = (options, duration, target) => {
    const targetEl = getJQueryEl(options, target);
    if (duration !== undefined) {
      const time = +duration.resolveValue(options);
      targetEl.slideUp(time || 1000);
    } else {
      targetEl.slideUp(1000);
    }
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode | undefined} [duration]
   * @param {ASTNode | undefined} [target]
   * @returns {void}
   */
  const slideToggle = (options, duration, target) => {
    const targetEl = getJQueryEl(options, target);
    if (duration !== undefined) {
      const time = +duration.resolveValue(options);
      targetEl.slideToggle(time || 1000);
    } else {
      targetEl.slideToggle(1000);
    }
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} classes
   * @param {ASTNode | undefined} [target]
   * @returns {void}
   */
  const addDiv = (options, classes, target) => {
    const targetEl = getJQueryEl(options, target);
    let classList = "";
    const classVal = classes.resolveValue(options);
    if (Array.isArray(classVal)) {
      classList = classVal.map((c) => c + "__" + options.callerId).join(" ");
    } else {
      classList = classVal + "__" + options.callerId;
    }
    targetEl.append(`<div class="${classList}"></div>`);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} classes
   * @param {ASTNode | undefined} [target]
   * @returns {void}
   */
  const removeDiv = (options, classes, target) => {
    const targetEl = getJQueryEl(options, target);
    let classList = "";
    const classVal = classes.resolveValue(options);
    if (Array.isArray(classVal)) {
      classList = "." + classVal.map((c) => c + "__" + options.callerId).join(".");
    } else {
      classList = "." + classVal + "__" + options.callerId;
    }
    targetEl.remove(classList);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {...ASTNode} [params]
   * @returns {boolean}
   */
  const and = (options, ...params) => {
    return params.every((a) => !!a.resolveValue(options)); // allows for quick fallout if falsy
  };
  /**
   * @param {BBScriptOptions} options
   * @param {...ASTNode} [params]
   * @returns {boolean}
   */
  const or = (options, ...params) => {
    return params.some((a) => !!a.resolveValue(options)); // allows for quick fallout if truthy
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} lhs
   * @param {ASTNode} rhs
   * @returns {boolean}
   */
  const equal = (options, lhs, rhs) => {
    // eslint-disable-next-line eqeqeq
    return lhs.resolveValue(options) == rhs.resolveValue(options);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} lhs
   * @param {ASTNode} rhs
   * @returns {boolean}
   */
  const notEqual = (options, lhs, rhs) => {
    // eslint-disable-next-line eqeqeq
    return lhs.resolveValue(options) != rhs.resolveValue(options);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} lhs
   * @param {ASTNode} rhs
   * @returns {boolean}
   */
  const greaterThan = (options, lhs, rhs) => {
    return lhs.resolveValue(options) > rhs.resolveValue(options);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} lhs
   * @param {ASTNode} rhs
   * @returns {boolean}
   */
  const greaterOrEqual = (options, lhs, rhs) => {
    return lhs.resolveValue(options) >= rhs.resolveValue(options);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} lhs
   * @param {ASTNode} rhs
   * @returns {boolean}
   */
  const lessThan = (options, lhs, rhs) => {
    return lhs.resolveValue(options) < rhs.resolveValue(options);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} lhs
   * @param {ASTNode} rhs
   * @returns {boolean}
   */
  const lessOrEqual = (options, lhs, rhs) => {
    return lhs.resolveValue(options) <= rhs.resolveValue(options);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} test
   * @param {ASTNode} caseTrue
   * @param {ASTNode | undefined} [caseFalse]
   * @returns {BBScriptReturnTypes}
   */
  const conditional = (options, test, caseTrue, caseFalse) => {
    const result = test.resolveValue(options);
    if (result) {
      return caseTrue.resolveValue(options);
    } else if (caseFalse !== undefined) {
      return caseFalse.resolveValue(options);
    }
  };
  /**
   * @param {BBScriptOptions} options
   * @param {...ASTNode} [exec]
   * @returns {BBScriptReturnTypes}
   */
  const group = (options, ...exec) => {
    const values = exec.map((a) => a.resolveValue(options));
    return values[values.length - 1];
  };
  /**
   * @returns {never}
   */
  const stop = () => {
    throw new Error("BBScript Stop Command"); // throw an error for easy exit and less try-catching
  };
  /**
   * @returns {number}
   */
  const random = () => {
    return Math.random();
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} min
   * @param {ASTNode} max
   * @returns {number}
   */
  const randomInt = (options, min, max) => {
    const minVal = +min.resolveValue(options);
    const maxVal = +max.resolveValue(options);
    return Math.floor(Math.random() * (maxVal - minVal + 1) + minVal);
  };
  /**
   * @returns {number}
   */
  const time = () => {
    return new Date().getTime();
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} secs
   * @param {ASTNode} func
   * @returns {number}
   */
  const timeoutFunc = (options, secs, func) => {
    const secsVal = secs.resolveValue(options);
    if (typeof secsVal !== "number") {
      throw new ASTError(secs, "Does not resolve to a number");
    }
    return setTimeout(
      () => {
        func.resolveValue(options);
      },
      Math.round(secsVal * 1000),
    );
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} id
   * @returns {void}
   */
  const clearTimeoutFunc = (options, id) => {
    const handle = +id.resolveValue(options);
    clearTimeout(handle);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} secs
   * @param {ASTNode} func
   * @returns {number}
   */
  const intervalFunc = (options, secs, func) => {
    const secsVal = secs.resolveValue(options);
    if (typeof secsVal !== "number") {
      throw new ASTError(secs, "Does not resolve to a number");
    }
    return setInterval(() => func.resolveValue(options), Math.round(secsVal * 1000));
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} id
   * @returns {void}
   */
  const clearIntervalFunc = (options, id) => {
    const handle = +id.resolveValue(options);
    clearInterval(handle);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {...ASTNode} [nodes]
   * @returns {void}
   */
  const print = (options, ...nodes) => {
    const values = nodes.map((n) => n.resolveValue(options));
    ConsoleLogger.log(...values);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} str
   * @param {ASTNode | undefined} [sep]
   * @returns {string[]}
   */
  const split = (options, str, sep) => {
    const strVal = String(str.resolveValue(options));
    let sepVal = "";
    if (sep !== undefined) {
      const res = sep.resolveValue(options);
      if (typeof res === "string") {
        sepVal = res;
      }
    }
    return strVal.split(sepVal);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} str
   * @returns {string}
   */
  const lower = (options, str) => {
    const strVal = String(str.resolveValue(options));
    return strVal.toLowerCase();
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} str
   * @returns {string}
   */
  const upper = (options, str) => {
    const strVal = String(str.resolveValue(options));
    return strVal.toUpperCase();
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} str
   * @returns {string}
   */
  const trim = (options, str) => {
    const strVal = String(str.resolveValue(options));
    return strVal.trim();
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} str
   * @param {ASTNode} needle
   * @param {ASTNode} replacement
   * @returns {string}
   */
  const replace = (options, str, needle, replacement) => {
    const strVal = String(str.resolveValue(options));
    return strVal.replaceAll(needle.resolveValue(options), replacement.resolveValue(options));
  };
  /**
   * create/assign to data variable
   * @param {BBScriptOptions} options
   * @param {ASTNode} variable
   * @param {ASTNode} input
   * @returns {void}
   */
  const assign = (options, variable, input) => {
    const value = input.resolveValue(options);
    let varName;
    if (variable instanceof ASTIdentifier) {
      varName = variable.name;
      // eslint-disable-next-line eqeqeq
      if (options.data[options.callerId] == undefined) {
        options.data[options.callerId] = {};
      }
      options.data[options.callerId][varName] = value;
      return;
    }
    throw new ASTError(variable, "Cannot assign to non identifier");
  };
  /**
   * JS loosy add for strings or nums
   * @param {BBScriptOptions} options
   * @param {...ASTNode} [params]
   * @returns {string | number}
   */
  const add = (options, ...params) => {
    const addElems = params.map((p) => p.resolveValue(options));
    return addElems.reduce((a, b) => a + b);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode[]} param
   * @returns {number[]}
   */
  const resolveToNums = (options, param) => {
    return param.map((p) => {
      const v = p.resolveValue(options);
      if (typeof v !== "number") {
        throw new ASTError(p, "Does not resolve to a number");
      }
      return v;
    });
  };
  /**
   * @param {BBScriptOptions} options
   * @param {...ASTNode} [params]
   * @returns {number}
   */
  const subtract = (options, ...params) => {
    const subElems = resolveToNums(options, params);
    return subElems.reduce((a, b) => a - b);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {...ASTNode} [params]
   * @returns {number}
   */
  const multiply = (options, ...params) => {
    const elems = resolveToNums(options, params);
    return elems.reduce((a, b) => a * b);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {...ASTNode} [params]
   * @returns {number}
   */
  const divide = (options, ...params) => {
    const elems = resolveToNums(options, params);
    return elems.reduce((a, b) => a / b);
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} value
   * @param {ASTNode} base
   * @returns {number}
   */
  const mod = (options, value, base) => {
    const [valueNum, baseNum] = resolveToNums(options, [value, base]);
    return valueNum % baseNum;
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} base
   * @param {ASTNode} expo
   * @returns {number}
   */
  const exp = (options, base, expo) => {
    const [expoNum, baseNum] = resolveToNums(options, [expo, base]);
    return baseNum ** expoNum;
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} variable
   * @returns {void}
   */
  const decrement = (options, variable) => {
    if (variable instanceof ASTIdentifier) {
      const varName = variable.name;
      if (
        // eslint-disable-next-line eqeqeq
        options.data[options.callerId] == undefined ||
        // eslint-disable-next-line eqeqeq
        options.data[options.callerId][varName] == undefined
      ) {
        throw new ASTError(variable, "Identifier not set yet");
      }
      if (typeof options.data[options.callerId][varName] !== "number") {
        throw new ASTError(variable, "Not a number");
      }
      options.data[options.callerId][varName] -= 1;
      return;
    }
    throw new ASTError(variable, "Not an identifier variable");
  };
  /**
   * @param {BBScriptOptions} options
   * @param {ASTNode} variable
   * @returns {void}
   */
  const increment = (options, variable) => {
    if (variable instanceof ASTIdentifier) {
      const varName = variable.name;
      if (
        // eslint-disable-next-line eqeqeq
        options.data[options.callerId] == undefined ||
        // eslint-disable-next-line eqeqeq
        options.data[options.callerId][varName] == undefined
      ) {
        throw new ASTError(variable, "Identifier not set yet");
      }
      if (typeof options.data[options.callerId][varName] !== "number") {
        throw new ASTError(variable, "Not a number");
      }
      options.data[options.callerId][varName] += 1;
      return;
    }
    throw new ASTError(variable, "Not an identifier variable");
  };
  const bbscriptFunctions = {
    count,
    contain,
    find,
    index,
    append,
    insert,
    pop,
    remove,
    reverse,
    join,
    shuffle,
    slice,
    each,
    addClass,
    removeClass,
    fadeIn,
    fadeOut,
    fadeToggle,
    hide,
    show,
    getText,
    setText,
    getVal,
    setVal,
    slideDown,
    slideUp,
    slideToggle,
    addDiv,
    removeDiv,
    and,
    or,
    "==": equal,
    "!=": notEqual,
    ">": greaterThan,
    ">=": greaterOrEqual,
    "<": lessThan,
    "<=": lessOrEqual,
    if: conditional,
    group,
    stop,
    random,
    randomInt,
    time,
    setTimeout: timeoutFunc,
    clearTimeout: clearTimeoutFunc,
    setInterval: intervalFunc,
    clearInterval: clearIntervalFunc,
    print,
    split,
    lower,
    upper,
    trim,
    replace,
    "=": assign,
    "+": add,
    "-": subtract,
    "*": multiply,
    "/": divide,
    "%": mod,
    "**": exp,
    "--": decrement,
    "++": increment,
  };

  /** @typedef {import('./processor').BBScriptOptions} BBScriptOptions */
  /**
   * @param {any} bbscriptData
   * @returns {{ processor: BBScript2Processor; parser: BBScriptParser; }}
   */
  function initBBScript2(bbscriptData) {
    return {
      processor: new BBScriptProcessor(bbscriptFunctions, { data: bbscriptData }),
      parser: new BBScriptParser(),
    };
  }

  /** @typedef {import('./bbscript1/processor').bbscriptOptions} bbscriptOptions */
  /** @typedef {import('./bbscript1/utils').astNode} astNode */
  /** @typedef {import('./bbscript2/AST').ASTNode} ASTNode */
  /** @typedef {import('./bbscript2/processor').BBScriptOptions} BBScriptOptions */
  const bbscriptData = {};
  const bbscriptProcessorV1 = initBBScript1(bbscriptData);
  const { processor: bbscriptProcessorV2, parser: bbscript2Parser } = initBBScript2(bbscriptData);
  // eslint-disable-next-line no-console
  console.info("BBCodePlus Addon JS Loaded");

  exports.bbscript2Parser = bbscript2Parser;
  exports.bbscriptData = bbscriptData;
  exports.bbscriptProcessorV1 = bbscriptProcessorV1;
  exports.bbscriptProcessorV2 = bbscriptProcessorV2;

}));
